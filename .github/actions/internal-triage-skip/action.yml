---
name: Skip Workflow if Labeled
description: >
    Skips the workflow if a label matches its filename (e.g. skip_aws_openshift_rosa_hcp_single_region_tests),
    or if the corresponding checkbox is checked in the auto-posted checklist comment.
    Also posts a checklist comment with all available skip options (created once, preserved thereafter).

outputs:
    should_skip:
        description: Indicates whether the workflow should be skipped
        value: ${{ steps.check_labels.outputs.workflow_should_skip }}

runs:
    using: composite
    steps:
        - name: Debug workflow context
          shell: bash
          run: |
              set -euo pipefail

              echo "[debug] github.actor='${{ github.actor }}'"
              if [[ "${{ github.actor }}" == "renovate[bot]" ]]; then
                echo "[debug] Actor is Renovate bot"
              else
                echo "[debug] Actor is NOT Renovate bot"
              fi
              echo "[debug] github.event_name='${{ github.event_name }}'"
              echo "[debug] github.repository='${{ github.repository }}'"
              echo "[debug] github.workflow_ref='${{ github.workflow_ref }}'"
              echo "[debug] github.run_id='${{ github.run_id }}' run_attempt='${{ github.run_attempt }}'"

              if [[ "${{ github.event_name }}" == "pull_request" ]]; then
                echo "[debug] pull_request.number='${{ github.event.pull_request.number }}'"
                echo "[debug] pull_request.head.ref='${{ github.event.pull_request.head.ref }}'"
                echo "[debug] pull_request.base.ref='${{ github.event.pull_request.base.ref }}'"
                echo "[debug] pull_request.title='${{ github.event.pull_request.title }}'"
                echo "[debug] Labels on PR:"
                echo '${{ toJSON(github.event.pull_request.labels.*.name) }}' | jq -r '.[]' || true
              elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
                echo "[debug] workflow_dispatch inputs (raw JSON):"
                if [[ -f "$GITHUB_EVENT_PATH" ]]; then
                  jq '.inputs // {}' "$GITHUB_EVENT_PATH" || true
                  echo "[debug] Flattened key=value inputs:"
                  jq -r '.inputs // {} | to_entries[] | "[debug] input." + .key + "=" + (.value|tostring)' "$GITHUB_EVENT_PATH" || true
                else
                  echo "[debug] No event payload file found ($GITHUB_EVENT_PATH)"
                fi
              else
                echo "[debug] Not a pull_request event; skipping PR-specific debug data."
              fi

        - name: Generate skip labels list
          id: generate_labels
          if: github.event_name == 'pull_request'
          shell: bash
          run: |
              set -euo pipefail

              has_error=false
              all_skip_labels=""

              # Generate skip labels from workflow files that use this action
              for workflow_file in .github/workflows/*.yml .github/workflows/*.yaml; do
                if [[ -f "$workflow_file" ]]; then
                  if grep -q "internal-triage-skip" "$workflow_file"; then
                    workflow_name=$(basename "$workflow_file" \
                      | sed 's/\(.*\)\.\(yaml\|yml\)$/\1/')
                    label_name="skip_${workflow_name}"

                    # Validate label length (GitHub max is 50 characters)
                    if [[ ${#label_name} -gt 50 ]]; then
                      echo "::error::Label '${label_name}' is ${#label_name} chars long." \
                        "Max is 50 characters. Please rename the workflow" \
                        "file '$(basename "$workflow_file")' to a shorter name."
                      has_error=true
                      continue
                    fi

                    all_skip_labels+="${label_name}"$'\n'
                  fi
                fi
              done

              # Remove trailing newline and sort
              all_skip_labels=$(echo "$all_skip_labels" | grep -v '^$' | sort)

              if [[ "$has_error" == "true" ]]; then
                echo "::error::One or more labels exceed the 50-character limit. See above for details."
                exit 1
              fi

              echo "[debug] Generated skip labels:"
              echo "$all_skip_labels"

              # Write multiline output using delimiter
              {
                echo "all_skip_labels<<LABELS_EOF"
                echo "$all_skip_labels"
                echo "LABELS_EOF"
              } >> "$GITHUB_OUTPUT"

        - name: Ensure skip labels exist
          if: github.event_name == 'pull_request'
          shell: bash
          env:
              GH_TOKEN: ${{ github.token }}
          run: |
              set -euo pipefail

              # Check if this is a fork PR (limited permissions)
              if [[ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]]; then
                echo "[debug] Fork PR detected - skipping label creation (insufficient permissions)"
                exit 0
              fi

              repo="${{ github.repository }}"
              label_color="1D76DB"
              all_skip_labels="${{ steps.generate_labels.outputs.all_skip_labels }}"

              if [[ -z "$all_skip_labels" ]]; then
                echo "[debug] No skip labels to create"
                exit 0
              fi

              # Fetch all existing labels once to minimize API calls
              echo "[debug] Fetching existing labels from repo..."
              existing_labels=$(gh label list --repo "$repo" \
                --json name --jq '.[].name' --limit 1000)

              # Helper: create label if not in existing_labels
              ensure_label() {
                local label_name="$1"
                local description="$2"

                if echo "$existing_labels" | grep -qx "$label_name"; then
                  echo "[debug] Label '$label_name' already exists"
                  return 0
                fi

                echo "[debug] Creating label '$label_name'..."
                create_output=$(gh label create "$label_name" --repo "$repo" \
                  --color "$label_color" \
                  --description "$description" 2>&1) && {
                  echo "[debug] Label '$label_name' created"
                } || {
                  if echo "$create_output" | grep -qi "already exists"; then
                    echo "[debug] Label '$label_name' already exists (race)"
                  else
                    echo "::warning::Failed to create label '$label_name': $create_output"
                  fi
                }
              }

              # Create missing skip labels
              while IFS= read -r label_name; do
                if [[ -n "$label_name" ]]; then
                  workflow_name="${label_name#skip_}"
                  ensure_label "$label_name" "Skip $workflow_name workflow"
                fi
              done <<< "$all_skip_labels"

              # Also ensure the skip_all label exists
              ensure_label "skip_all" "Skip all workflows"

        - name: Post skip checklist comment (if not exists)
          id: post_checklist
          if: github.event_name == 'pull_request'
          shell: bash
          env:
              GH_TOKEN: ${{ github.token }}
          run: |
              set -euo pipefail

              # Check if this is a fork PR (limited permissions)
              if [[ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]]; then
                echo "[debug] Fork PR detected - skipping checklist comment (insufficient permissions)"
                exit 0
              fi

              pr_number="${{ github.event.pull_request.number }}"
              repo="${{ github.repository }}"
              checklist_marker="<!-- skip-workflow-checklist -->"

              # Helper function to handle GitHub API errors
              handle_gh_error() {
                local exit_code=$1
                local operation=$2
                local output=$3

                if [[ $exit_code -eq 0 ]]; then
                  return 0
                fi

                # Check for specific error types
                if echo "$output" | grep -qi "rate limit"; then
                  echo "::warning::GitHub API rate limit hit during $operation"
                  return 1
                elif echo "$output" | grep -qi "401\|403\|authentication\|unauthorized"; then
                  echo "::error::Authentication error during $operation - check token permissions"
                  return 1
                elif echo "$output" | grep -qi "404\|not found"; then
                  echo "[debug] Resource not found during $operation (may be expected)"
                  return 0  # 404 is often expected (e.g., comment already deleted)
                elif echo "$output" | grep -qi "network\|connection\|timeout"; then
                  echo "::warning::Network error during $operation"
                  return 1
                else
                  echo "::warning::Unexpected error during $operation: $output"
                  return 1
                fi
              }

              # Reuse skip labels computed in the generate_labels step
              all_skip_labels="${{ steps.generate_labels.outputs.all_skip_labels }}"

              if [[ -z "$all_skip_labels" ]]; then
                echo "[debug] No skip labels found, skipping checklist creation"
                exit 0
              fi

              echo "[debug] Skip labels for checklist:"
              echo "$all_skip_labels"

              # Check if a checklist comment already exists
              gh_output=$(gh pr view "$pr_number" --repo "$repo" --json comments 2>&1) || {
                handle_gh_error $? "fetching PR comments" "$gh_output"
                exit 0  # Non-critical: continue workflow even if we can't post checklist
              }
              existing_comment_id=$(echo "$gh_output" | jq -r ".comments[] | select(.body | contains(\"$checklist_marker\")) | .id" | head -1)

              # Build the checklist content
              checklist_body="${checklist_marker}"$'\n'
              checklist_body+="## ðŸ”€ Skip Workflow Checklist"$'\n\n'
              checklist_body+="Check the boxes below to skip specific workflows for this PR."$'\n\n'
              checklist_body+="### Global options"$'\n'
              checklist_body+="- [ ] \`skip_all\` - Skip all workflows"$'\n\n'
              checklist_body+="### Individual workflows"$'\n'

              while IFS= read -r label; do
                if [[ -n "$label" ]]; then
                  checklist_body+="- [ ] \`$label\`"$'\n'
                fi
              done <<< "$all_skip_labels"

              checklist_body+=$'\n'"---"$'\n'
              checklist_body+="*This checklist is automatically managed. Checked items will skip the corresponding workflow.*"

              if [[ -n "$existing_comment_id" ]]; then
                echo "[debug] Checklist comment already exists (ID: $existing_comment_id), preserving user selections"
                # Don't update - we want to preserve user's checkbox selections
              else
                # Race condition prevention: add random delay to desynchronize parallel workflows
                # Using /dev/urandom for better entropy than $RANDOM (which can be identical across parallel processes)
                random_delay=$(od -An -tu1 -N1 /dev/urandom | tr -d ' ')
                random_delay=$((random_delay % 15 + 1))
                echo "[debug] Waiting ${random_delay}s before creating comment (race condition prevention)..."
                sleep "$random_delay"

                # Re-check if another workflow created the comment during our delay
                gh_output=$(gh pr view "$pr_number" --repo "$repo" --json comments 2>&1) || {
                  handle_gh_error $? "re-checking PR comments" "$gh_output"
                  exit 0
                }
                existing_comment_id=$(echo "$gh_output" | jq -r ".comments[] | select(.body | contains(\"$checklist_marker\")) | .id" | head -1)

                if [[ -n "$existing_comment_id" ]]; then
                  echo "[debug] Comment was created by another workflow during delay (ID: $existing_comment_id), skipping creation"
                else
                  echo "[debug] Creating new checklist comment..."
                  gh_output=$(gh pr comment "$pr_number" --repo "$repo" --body "$checklist_body" 2>&1) || {
                    handle_gh_error $? "creating comment" "$gh_output"
                    exit 0
                  }
                  echo "[debug] Checklist comment created"

                  # Handle race condition: poll for duplicates with timeout instead of fixed delay
                  # This is more efficient as it exits early when no duplicates are found
                  max_attempts=10
                  poll_interval=1
                  attempt=0
                  duplicates_cleaned=false

                  echo "[debug] Polling for duplicate comments (max ${max_attempts}s)..."
                  while [[ $attempt -lt $max_attempts ]]; do
                    sleep "$poll_interval"
                    attempt=$((attempt + 1))

                    # Use REST API to get numeric comment IDs (gh pr view returns GraphQL node IDs which break tonumber and REST DELETE)
                    gh_output=$(gh api "/repos/$repo/issues/$pr_number/comments?per_page=100" 2>&1) || {
                      handle_gh_error $? "fetching comments for cleanup (attempt $attempt)" "$gh_output"
                      break
                    }
                    # Sort by created_at first, then by id (numeric) for deterministic ordering
                    # This ensures consistent behavior even with identical timestamps
                    # Lowest ID wins as it was created first by GitHub's sequential ID assignment
                    jq_filter='[.[] | select(.body | contains("'"$checklist_marker"'"))'
                    jq_filter+=' | {id: .id, createdAt: .created_at,'
                    jq_filter+=' hasCheckboxChecked: (.body | test("- \\[[xX]\\]"))}]'
                    jq_filter+=' | sort_by([.createdAt, .id])'
                    all_checklist_comments=$(echo "$gh_output" | jq "$jq_filter")
                    comment_count=$(echo "$all_checklist_comments" | jq 'length')

                    if [[ "$comment_count" -eq 1 ]]; then
                      echo "[debug] Single comment confirmed after ${attempt}s, no cleanup needed"
                      break
                    elif [[ "$comment_count" -gt 1 ]]; then
                      echo "[debug] Race condition detected: $comment_count checklist comments found after ${attempt}s, cleaning up duplicates..."

                      # Check if any comment has user interactions (checked checkboxes)
                      # If so, prefer keeping that one instead of just the oldest
                      interacted_comment_id=$(echo "$all_checklist_comments" | jq -r '[.[] | select(.hasCheckboxChecked == true)] | first | .id // empty')

                      if [[ -n "$interacted_comment_id" ]]; then
                        echo "[debug] Found comment with user interactions (ID: $interacted_comment_id), preserving it"
                        comment_to_keep="$interacted_comment_id"
                      else
                        # No interactions found, keep the oldest (first by createdAt, then by lowest id)
                        comment_to_keep=$(echo "$all_checklist_comments" | jq -r '.[0].id')
                        echo "[debug] No user interactions detected, keeping oldest comment (ID: $comment_to_keep)"
                      fi

                      # Delete all comments except the one to keep
                      comments_to_delete=$(echo "$all_checklist_comments" | jq -r --arg keep "$comment_to_keep" '[.[] | select(.id != ($keep | tonumber))] | .[].id')
                      for comment_id in $comments_to_delete; do
                        echo "[debug] Deleting duplicate comment: $comment_id"
                        delete_output=$(gh api --method DELETE "/repos/$repo/issues/comments/$comment_id" 2>&1) || {
                          handle_gh_error $? "deleting duplicate comment $comment_id" "$delete_output"
                          # Continue trying to delete other duplicates even if one fails
                        }
                      done
                      duplicates_cleaned=true
                      echo "[debug] Cleanup complete, kept comment $comment_to_keep"
                      break
                    else
                      echo "[debug] No comments found yet (attempt $attempt/$max_attempts), waiting for API consistency..."
                    fi
                  done

                  if [[ $attempt -eq $max_attempts && "$duplicates_cleaned" != "true" ]]; then
                    echo "[debug] Polling timeout reached, assuming no duplicates"
                  fi
                fi
              fi

        - name: Get the current workflow filename and check for skip labels
          id: check_labels
          shell: bash
          env:
              GH_TOKEN: ${{ github.token }}
          run: |
              set -euo pipefail

              if [[ "${{ github.event_name }}" != "pull_request" ]]; then
                echo "workflow_should_skip=false" | tee -a "$GITHUB_OUTPUT"
                exit 0
              fi

              workflow_file_name=$(echo "${{ github.workflow_ref }}" | sed 's/@.*//')
              workflow_file_name=$(basename "$workflow_file_name" | sed 's/\(.*\)\(\.yaml\|\.yml\)$/\1/')
              echo "workflow_file_name=$workflow_file_name" | tee -a "$GITHUB_ENV"

              # Fetch fresh labels from GitHub API using gh CLI
              pr_number="${{ github.event.pull_request.number }}"
              repo="${{ github.repository }}"

              echo "[debug] Fetching fresh labels for PR #$pr_number in $repo"
              labels=$(gh pr view "$pr_number" --repo "$repo" --json labels --jq '.labels[].name')

              echo "[debug] Fresh labels from API:"
              echo "$labels"

              skip_pattern="skip_$workflow_file_name"

              # Check labels (skip_all and testing-ci-not-necessary skip everything)
              if echo "$labels" | grep -qE "$skip_pattern|skip_all|testing-ci-not-necessary"; then
                echo "[debug] Skip directive found in labels"
                echo "workflow_should_skip=true" | tee -a "$GITHUB_OUTPUT"
                exit 0
              fi

              # Check for checked checkbox in the checklist comment
              # Pattern: - [x] `skip_workflow_name` or - [X] `skip_workflow_name`
              checklist_marker="<!-- skip-workflow-checklist -->"
              checklist_comment=$(gh pr view "$pr_number" --repo "$repo" --json comments \
                --jq "[.comments[] | select(.body | contains(\"$checklist_marker\")) | .body] | first // \"\"")

              if echo "$checklist_comment" | grep -qE "\- \[[xX]\] \`$skip_pattern\`"; then
                echo "[debug] Skip directive found in checklist (checkbox checked)"
                echo "workflow_should_skip=true" | tee -a "$GITHUB_OUTPUT"
                exit 0
              fi

              # Check for skip_all checked in checklist
              if echo "$checklist_comment" | grep -qE "\- \[[xX]\] \`skip_all\`"; then
                echo "[debug] skip_all found checked in checklist"
                echo "workflow_should_skip=true" | tee -a "$GITHUB_OUTPUT"
                exit 0
              fi

              echo "[debug] No skip directive found"
              echo "workflow_should_skip=false" | tee -a "$GITHUB_OUTPUT"
