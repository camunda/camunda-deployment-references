---
name: Kubernetes Wildcard Certificate Setup
description: Setup wildcard TLS certificate from Vault for Kubernetes clusters

inputs:
    tld:
        description: Top-level domain for the wildcard certificate
        required: false
        default: camunda.ie
    namespace:
        description: Kubernetes namespace where cert-manager resources will be created
        required: false
        default: cert-manager
    vault-addr:
        description: Vault server address
        required: true
    vault-role-id:
        description: Vault AppRole role ID
        required: true
    vault-secret-id:
        description: Vault AppRole secret ID
        required: true

runs:
    using: composite
    steps:
        - name: üîê Import wildcard certificate from Vault
          uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3
          with:
              url: ${{ inputs.vault-addr }}
              method: approle
              roleId: ${{ inputs.vault-role-id }}
              secretId: ${{ inputs.vault-secret-id }}
              secrets: |
                  secret/data/products/infrastructure-experience/certificates/${{ inputs.tld }}/wildcard certificate | WILDCARD_CERT ;
                  secret/data/products/infrastructure-experience/certificates/${{ inputs.tld }}/wildcard private_key | WILDCARD_KEY

        - name: üìú Setup wildcard certificate resources
          shell: bash
          run: |
              set -euo pipefail

              echo "üåê Setting up wildcard certificate for *.${{ inputs.tld }}"
              echo "üìç Target namespace: ${{ inputs.namespace }}"

              # Mask sensitive certificate data in logs
              echo "::add-mask::$WILDCARD_CERT"
              echo "::add-mask::$WILDCARD_KEY"

              # Validate that certificates were retrieved
              if [[ -z "${WILDCARD_CERT:-}" ]]; then
                  echo "‚ùå ERROR: Failed to retrieve certificate from Vault"
                  exit 1
              fi

              if [[ -z "${WILDCARD_KEY:-}" ]]; then
                  echo "‚ùå ERROR: Failed to retrieve private key from Vault"
                  exit 1
              fi

              echo "‚úÖ Successfully retrieved certificates from Vault"
              echo "üîí Certificate data is masked in logs for security"

              # Create dummy cluster issuer for wildcard certificates
              echo "üîß Creating wildcard cluster issuer for certificates..."

              # Read dummy CA certificate and key from files in the action directory
              ACTION_DIR="${GITHUB_ACTION_PATH:-${{ github.action_path }}}"
              DUMMY_CERT=$(cat "$ACTION_DIR/dummy-ca.crt.b64" | tr -d '\n')
              DUMMY_KEY=$(cat "$ACTION_DIR/dummy-ca.key.b64" | tr -d '\n')

              kubectl apply -f - <<EOF
              apiVersion: cert-manager.io/v1
              kind: ClusterIssuer
              metadata:
                name: wildcard-cluster-issuer
              spec:
                ca:
                  secretName: wildcard-dummy-ca-secret
              ---
              apiVersion: v1
              kind: Secret
              metadata:
                name: wildcard-dummy-ca-secret
                namespace: ${{ inputs.namespace }}
              type: Opaque
              data:
                tls.crt: ${DUMMY_CERT}
                tls.key: ${DUMMY_KEY}
              EOF

              # Create wildcard certificate and secret
              echo "üîë Creating wildcard certificate and TLS secret..."

              # Create temporary files for certificate data
              TEMP_DIR=$(mktemp -d)
              CERT_FILE="$TEMP_DIR/tls.crt"
              KEY_FILE="$TEMP_DIR/tls.key"
              MANIFEST_FILE="$TEMP_DIR/wildcard-resources.yaml"

              # Cleanup function
              cleanup() {
                  echo "üßπ Cleaning up temporary files..."
                  rm -rf "$TEMP_DIR"
              }
              trap cleanup EXIT

              # Write certificate data to files
              echo "üìù Writing certificate data to temporary files..."
              echo "$WILDCARD_CERT" > "$CERT_FILE"
              echo "$WILDCARD_KEY" > "$KEY_FILE"

              # Create the Kubernetes manifest
              cat > "$MANIFEST_FILE" <<EOF
              apiVersion: cert-manager.io/v1
              kind: Certificate
              metadata:
                name: wildcard-certificate
                namespace: ${{ inputs.namespace }}
              spec:
                secretName: wildcard-tls-secret
                issuerRef:
                  name: wildcard-cluster-issuer
                  kind: ClusterIssuer
                commonName: "*.${{ inputs.tld }}"
                dnsNames:
                - "*.${{ inputs.tld }}"
                - "${{ inputs.tld }}"
              EOF

              # Create the TLS secret using kubectl with file references
              echo "üîê Creating TLS secret from certificate files..."
              kubectl create secret tls wildcard-tls-secret \
                  --cert="$CERT_FILE" \
                  --key="$KEY_FILE" \
                  --namespace="${{ inputs.namespace }}" \
                  --dry-run=client -o yaml | \
              kubectl annotate -f - --local \
                  cert-manager.io/certificate-name=wildcard-certificate \
                  --dry-run=client -o yaml | \
              kubectl apply -f -

              # Apply the Certificate resource
              echo "üìú Creating Certificate resource..."
              kubectl apply -f "$MANIFEST_FILE"

              echo "‚úÖ Wildcard certificate setup completed successfully"
              echo ""
              echo "üìã Created resources:"
              echo "  - ClusterIssuer: wildcard-cluster-issuer (cluster-wide)"
              echo "  - Certificate: wildcard-certificate (namespace: ${{ inputs.namespace }})"
              echo "  - Secret: wildcard-tls-secret (namespace: ${{ inputs.namespace }})"
              echo ""
              echo "üîí Security: All certificate data is masked in logs"
              echo "üéØ Usage options:"
              echo "  1. Direct reference: secretName: wildcard-tls-secret"
              echo "  2. Auto-generation: cert-manager.io/cluster-issuer: wildcard-cluster-issuer"
