---
name: Camunda Chart Tests

description: >
    Run the Camunda Helm chart tests.
    Already requires the Helm chart to be deployed and cluster access granted.

inputs:
    tests-camunda-helm-chart-repo-ref:
        description: The branch, tag or commit to checkout
        default: main
    tests-camunda-helm-chart-repo-path:
        description: Path to the Helm chart repository
        default: ./.camunda_helm_repo
    secrets:
        description: JSON wrapped secrets for easier secret passing
        required: true
    camunda-version:
        description: The version of the Camunda Helm chart to test
        required: true
    camunda-domain:
        description: The domain to use for the tests
        default: ''
    camunda-domain-grpc:
        description: The domain to use for the gRPC tests
        default: ''
    webmodeler-enabled:
        description: Whether the Webmodeler is enabled in the chart
        default: 'false'
    console-enabled:
        description: Whether the Console is enabled in the chart
        default: 'false'
    elasticsearch-enabled:
        description: Whether the Elasticsearch is enabled in the chart
        default: 'true'
    test-namespace:
        description: The namespace to use for the helm tests
        default: camunda
    test-release-name:
        description: The helm release name to used for by the helm tests
        default: camunda
    test-cluster-type:
        description: The type of the cluster to use for the tests
        default: kubernetes
    zeebe-topology-golden-file:
        description: The golden file to compare the Zeebe topology output against.
        default: ./generic/kubernetes/single-region/procedure/check-zeebe-cluster-topology-output.json
    zeebe-topology-check-script:
        description: The script called to the current Zeebe topology.
        default: ./generic/kubernetes/single-region/procedure/check-zeebe-cluster-topology.sh
    zeebe-authenticated:
        description: Use the authentication layer to interact with zeebe
        default: 'true'
    enable-helm-chart-tests:
        description: Whether the Helm Chart tests should be run
        default: 'true'
    enable-zeebe-client-tests:
        description: Whether the Zeebe Client tests should be run
        default: 'true'
    enable-playwright-tests:
        description: Whether the Playwright tests should be run
        default: 'true'
    playwright-test-suite:
        description: The Playwright test suite to run (smoke-tests or full-suite)
        default: full-suite
    cluster-2-name:
        description: Optional cluster 2 name for sed replacement (dual-region only)
        required: false
    camunda-namespace-2:
        description: Optional namespace for region 2 (dual-region only)
        required: false
    camunda-namespace-1:
        description: Optional namespace for region 1 (dual-region only)
        required: false
    keycloak-service-name:
        description: Name of the Keycloak service with optional port (e.g. keycloak-service:8080)
        default: ''  # Will use ${CAMUNDA_RELEASE_NAME}-keycloak by default
    elasticsearch-service-name:
        description: Name of the Elasticsearch service with optional port (e.g. elasticsearch-es-http:9200)
        default: ''  # Will use ${CAMUNDA_RELEASE_NAME}-elasticsearch by default
    test-client-id:
        description: Client ID for Camunda authentication tests
        required: true
    test-client-secret:
        description: Client secret for Camunda authentication tests
        required: true
    connectors-client-secret:
        description: Client secret for Connectors component
        required: false
        default: ''
    optimize-client-secret:
        description: Client secret for Optimize component
        required: false
        default: ''
    orchestration-client-secret:
        description: Client secret for Orchestration (Zeebe) component
        required: false
        default: ''
    admin-client-secret:
        description: Client secret for Admin component
        required: false
        default: ''

runs:
    using: composite
    steps:
        - name: Import Secrets
          id: secrets
          if: ${{ inputs.enable-helm-chart-tests == 'true' || inputs.zeebe-authenticated == 'true' || inputs.enable-playwright-tests == 'true' }}
          uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3
          with:
              url: ${{ fromJSON(inputs.secrets).VAULT_ADDR }}
              method: approle
              roleId: ${{ fromJSON(inputs.secrets).VAULT_ROLE_ID }}
              secretId: ${{ fromJSON(inputs.secrets).VAULT_SECRET_ID }}
              exportEnv: false
              secrets: |
                  secret/data/products/infrastructure-experience/ci/common DOCKERHUB_USER;
                  secret/data/products/infrastructure-experience/ci/common DOCKERHUB_PASSWORD;

        - name: üßô‚Äç‚ôÇÔ∏è Clone camunda/camunda-platform-helm
          uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
          if: ${{ inputs.enable-helm-chart-tests == 'true' || inputs.enable-playwright-tests == 'true' }}
          with:
              repository: camunda/camunda-platform-helm
              ref: ${{ inputs.tests-camunda-helm-chart-repo-ref }}
              path: ${{ inputs.tests-camunda-helm-chart-repo-path }}
              fetch-depth: 0

        - name: üß™ TESTS - Set variables
          if: ${{ inputs.enable-helm-chart-tests == 'true' || inputs.enable-playwright-tests == 'true' }}
          shell: bash
          env:
              CAMUNDA_VERSION: ${{ inputs.camunda-version }}
              CAMUNDA_DOMAIN: ${{ inputs.camunda-domain }}
              CAMUNDA_DOMAIN_GRPC: ${{ inputs.camunda-domain-grpc }}
              WEBMODELER_ENABLED: ${{ inputs.webmodeler-enabled }}
              CONSOLE_ENABLED: ${{ inputs.console-enabled }}
              ELASTICSEARCH_ENABLED: ${{ inputs.elasticsearch-enabled }}
          run: |
              set -euo pipefail

              # export test variables to be used in other steps
              echo "TEST_NAMESPACE=${{ inputs.test-namespace }}" | tee -a "$GITHUB_ENV"
              echo "TEST_CHART_NAME=${{ inputs.test-release-name }}" | tee -a "$GITHUB_ENV"
              echo "TEST_CLUSTER_TYPE=$TEST_CLUSTER_TYPE" | tee -a "$GITHUB_ENV"
              export TESTS_CAMUNDA_HELM_CHART_REPO_PATH="${{ inputs.tests-camunda-helm-chart-repo-path }}"
              echo "TESTS_CAMUNDA_HELM_CHART_REPO_PATH=$TESTS_CAMUNDA_HELM_CHART_REPO_PATH" | tee -a "$GITHUB_ENV"

              export TEST_CHART_DIR_STATIC="$TESTS_CAMUNDA_HELM_CHART_REPO_PATH/charts/camunda-platform-$CAMUNDA_VERSION"
              echo "TEST_CHART_DIR_STATIC=$TEST_CHART_DIR_STATIC" | tee -a "$GITHUB_ENV"

              TEST_INGRESS_HOST="$CAMUNDA_DOMAIN"
              echo "TEST_INGRESS_HOST=$TEST_INGRESS_HOST" | tee -a "$GITHUB_ENV"

              # shellcheck disable=SC2002
              TEST_CHART_VERSION=$(cat "$TEST_CHART_DIR_STATIC/Chart.yaml" | yq '.version')
              echo "TEST_CHART_VERSION=$TEST_CHART_VERSION" | tee -a "$GITHUB_ENV"

              # setup docker registry secret for tests
              echo "TEST_CREATE_DOCKER_LOGIN_SECRET=true" | tee -a "$GITHUB_ENV"
              echo "TEST_DOCKER_USERNAME_CAMUNDA_CLOUD=${{ steps.secrets.outputs.DOCKERHUB_USERNAME }}" | tee -a "$GITHUB_ENV"
              echo "TEST_DOCKER_PASSWORD_CAMUNDA_CLOUD=${{ steps.secrets.outputs.DOCKERHUB_PASSWORD }}" | tee -a "$GITHUB_ENV"

              CI_TASKS_BASE_DIR="$TESTS_CAMUNDA_HELM_CHART_REPO_PATH/test/integration/scenarios/"
              echo "CI_TASKS_BASE_DIR=$CI_TASKS_BASE_DIR" | tee -a "$GITHUB_ENV"
              export TEST_CHART_DIR="../../../../charts/camunda-platform-$CAMUNDA_VERSION"
              echo "TEST_CHART_DIR=$TEST_CHART_DIR" | tee -a "$GITHUB_ENV"
              export TEST_VALUES_BASE_DIR="$TESTS_CAMUNDA_HELM_CHART_REPO_PATH/test/integration/scenarios"
              echo "TEST_VALUES_BASE_DIR=$TEST_VALUES_BASE_DIR" | tee -a "$GITHUB_ENV"

              # Set Playwright test directories based on version
              if [[ -d "$TEST_CHART_DIR_STATIC/test/integration/testsuites" ]]; then
                  echo "PLAYWRIGHT_TEST_DIR=$TEST_CHART_DIR_STATIC/test/integration/testsuites" | tee -a "$GITHUB_ENV"
              elif [[ -d "$TEST_CHART_DIR_STATIC/test/e2e" ]]; then
                  echo "PLAYWRIGHT_TEST_DIR=$TEST_CHART_DIR_STATIC/test/e2e" | tee -a "$GITHUB_ENV"
              else
                  echo "‚ö†Ô∏è No Playwright test directory found for version $CAMUNDA_VERSION"
              fi

              # replace integration with the camunda release name as part of adaptation required to run the tests in our environment
              if [[ "${{ inputs.enable-helm-chart-tests }}" == "true" ]]; then
                find "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/" -type f -print0 | xargs -0 sed -i "s/integration/$CAMUNDA_RELEASE_NAME/g"

                # Replace Keycloak service references with custom service name if provided
                KEYCLOAK_SERVICE_INPUT="${{ inputs.keycloak-service-name }}"
                if [[ -n "$KEYCLOAK_SERVICE_INPUT" && "$KEYCLOAK_SERVICE_INPUT" != "${CAMUNDA_RELEASE_NAME}-keycloak" ]]; then
                  echo "Processing Keycloak service configuration: $KEYCLOAK_SERVICE_INPUT"

                  # Use the service name with port directly (expected format: service-name:port)
                  KEYCLOAK_TARGET="$KEYCLOAK_SERVICE_INPUT"
                  echo "Replacing Keycloak references with: $KEYCLOAK_TARGET"

                  # Ultra-generic approach: replace any keycloak pattern with our target
                  # This covers all possible variations in a single sed command per file type
                  find "$TEST_CHART_DIR_STATIC/test/integration/" -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) -print0 | \
                    xargs -0 sed -i \
                      -e "s|${CAMUNDA_RELEASE_NAME}-keycloak:80|${KEYCLOAK_TARGET}|g" \
                      -e "s|${CAMUNDA_RELEASE_NAME}-keycloak\"|${KEYCLOAK_TARGET}\"|g" \
                      -e "s|${CAMUNDA_RELEASE_NAME}-keycloak|${KEYCLOAK_TARGET}|g" \
                      -e "s|camunda-keycloak:80|${KEYCLOAK_TARGET}|g" \
                      -e "s|camunda-keycloak\"|${KEYCLOAK_TARGET}\"|g" \
                      -e "s|camunda-keycloak|${KEYCLOAK_TARGET}|g" \
                      -e "s|http://${CAMUNDA_RELEASE_NAME}-keycloak|http://${KEYCLOAK_TARGET}|g" \
                      -e "s|http://camunda-keycloak|http://${KEYCLOAK_TARGET}|g" \
                      -e "s|\"keycloak\":\"http://[^\"]*keycloak[^\"]*\"|\"keycloak\":\"http://${KEYCLOAK_TARGET}\"|g" \
                      -e "s|keycloak: http://[^[:space:]]*keycloak[^[:space:]]*|keycloak: http://${KEYCLOAK_TARGET}|g"

                  echo "‚úÖ Keycloak service references updated to: $KEYCLOAK_TARGET"

                  # Debug: Show what Keycloak references exist after modification
                  echo "Current Keycloak references in test files:"
                  grep -r "keycloak" "$TEST_CHART_DIR_STATIC/test/integration/" 2>/dev/null | head -10 || echo "No keycloak references found"
                  echo ""
                  echo "JSON baseURLs configuration:"
                  grep -r "baseURLs" "$TEST_CHART_DIR_STATIC/test/integration/" 2>/dev/null | head -3 || echo "No baseURLs found"
                else
                  echo "Using default Keycloak service name: ${CAMUNDA_RELEASE_NAME}-keycloak"
                fi

                # Replace Elasticsearch service references with custom service name if provided
                ELASTICSEARCH_SERVICE_INPUT="${{ inputs.elasticsearch-service-name }}"
                if [[ -n "$ELASTICSEARCH_SERVICE_INPUT" && "$ELASTICSEARCH_SERVICE_INPUT" != "${CAMUNDA_RELEASE_NAME}-elasticsearch" ]]; then
                  echo "Processing Elasticsearch service configuration: $ELASTICSEARCH_SERVICE_INPUT"

                  # Use the service name with port directly (expected format: service-name:port)
                  ELASTICSEARCH_TARGET="$ELASTICSEARCH_SERVICE_INPUT"
                  echo "Replacing Elasticsearch references with: $ELASTICSEARCH_TARGET"

                  # Ultra-generic approach: replace any elasticsearch pattern with our target
                  find "$TEST_CHART_DIR_STATIC/test/integration/" -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) -print0 | \
                    xargs -0 sed -i \
                      -e "s|${CAMUNDA_RELEASE_NAME}-elasticsearch:9200|${ELASTICSEARCH_TARGET}|g" \
                      -e "s|${CAMUNDA_RELEASE_NAME}-elasticsearch\"|${ELASTICSEARCH_TARGET}\"|g" \
                      -e "s|${CAMUNDA_RELEASE_NAME}-elasticsearch|${ELASTICSEARCH_TARGET}|g" \
                      -e "s|camunda-elasticsearch:9200|${ELASTICSEARCH_TARGET}|g" \
                      -e "s|camunda-elasticsearch\"|${ELASTICSEARCH_TARGET}\"|g" \
                      -e "s|camunda-elasticsearch|${ELASTICSEARCH_TARGET}|g" \
                      -e "s|http://${CAMUNDA_RELEASE_NAME}-elasticsearch|http://${ELASTICSEARCH_TARGET}|g" \
                      -e "s|https://${CAMUNDA_RELEASE_NAME}-elasticsearch|https://${ELASTICSEARCH_TARGET}|g" \
                      -e "s|http://camunda-elasticsearch|http://${ELASTICSEARCH_TARGET}|g" \
                      -e "s|https://camunda-elasticsearch|https://${ELASTICSEARCH_TARGET}|g" \
                      -e "s|\"elasticsearch\":\"http://[^\"]*elasticsearch[^\"]*\"|\"elasticsearch\":\"http://${ELASTICSEARCH_TARGET}\"|g" \
                      -e "s|\"elasticsearch\":\"https://[^\"]*elasticsearch[^\"]*\"|\"elasticsearch\":\"https://${ELASTICSEARCH_TARGET}|g" \
                      -e "s|elasticsearch: http://[^[:space:]]*elasticsearch[^[:space:]]*|elasticsearch: http://${ELASTICSEARCH_TARGET}|g" \
                      -e "s|elasticsearch: https://[^[:space:]]*elasticsearch[^[:space:]]*|elasticsearch: https://${ELASTICSEARCH_TARGET}|g"

                  echo "‚úÖ Elasticsearch service references updated to: $ELASTICSEARCH_TARGET"

                  # Debug: Show what Elasticsearch references exist after modification
                  echo "Current Elasticsearch references in test files:"
                  grep -r "elasticsearch" "$TEST_CHART_DIR_STATIC/test/integration/" 2>/dev/null | head -10 || echo "No elasticsearch references found"
                else
                  echo "Using default Elasticsearch service name: ${CAMUNDA_RELEASE_NAME}-elasticsearch"
                fi

                echo "Configure Venom tests"
                # (adapted from https://github.com/camunda/camunda-platform-helm/blob/test/integration/scenarios/chart-full-setup/Taskfile.yaml#L56)
                export VARIABLES_ENV_FILE="$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables.env"

                # False because we run OIDC
                echo "VENOM_VAR_SKIP_TEST_KEYCLOAK=false" >> "$VARIABLES_ENV_FILE"

                # Enable the ingress tests

                if [[ "$CAMUNDA_DOMAIN" != "" ]]; then
                  # shellcheck disable=SC2129
                  echo "VENOM_VAR_TEST_INGRESS_HOST=$TEST_INGRESS_HOST" >> "$VARIABLES_ENV_FILE"
                  echo "VENOM_EXTRA_ARGS=--var-from-file=./vars/variables-ingress-combined.yaml" >> "$VARIABLES_ENV_FILE"

                  # Setting is broken and results in always skipping ingress tests
                  # This removes the faulty setting but should only be done in domain context
                  echo "Skip test ingress is also broken, fixing it"
                  yq eval '(.testcases[].steps[].skip |= map(select(test("skiptestingress", "i") | not)))' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml"
                  yq eval 'del(.. | select(has("skip") and .skip | length == 0).skip)' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml"

                  if [[ "$CAMUNDA_DOMAIN_GRPC" != "" ]]; then
                    yq eval '.coreVars.baseURLs.orchestrationGRPC = env(CAMUNDA_DOMAIN_GRPC)' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"
                  fi
                else
                  # Some variables are not working correctly, patching it with yq directly
                  echo "VENOM_VAR_SKIP_TEST_INGRESS=true" >> "$VARIABLES_ENV_FILE"

                  # fix wrong default orchestrationGRPC port
                  yq eval '.coreVars.baseURLs.orchestrationGRPC |= (select(tag == "!!str") | sub("^http://", "") | sub(":9600$", ":26500"))' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"
                fi

                echo "VENOM_VAR_TEST_CLIENT_ID=${{ inputs.test-client-id }}" >> "$VARIABLES_ENV_FILE"
                echo "VENOM_VAR_TEST_CLIENT_SECRET=${{ inputs.test-client-secret }}" >> "$VARIABLES_ENV_FILE"

                ZEEBE_VERSION=$(yq '.zeebe.image.tag' "$TEST_CHART_DIR_STATIC/values.yaml")
                # shellcheck disable=SC2129
                echo "ZEEBE_VERSION=$ZEEBE_VERSION" >> "$VARIABLES_ENV_FILE"
                # In case the Zeebe version has not been released officially yet.
                echo "ZEEBE_VERSION_FALLBACK=8.5.6" >> "$VARIABLES_ENV_FILE"

                echo "Patch the test files..."

                # TODO: [BUG] remove the patchs when https://github.com/camunda/camunda-platform-helm/issues/3081 is fixed
                echo "Patch expression ShoudBeFalse"
                sed -i "s/ ShouldBeFalse/ ShouldEqual 'false'/g" \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml" \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-preflight.yaml"

                echo "Patch expression ShouldBeTrue"
                sed -i "s/ ShouldBeTrue/ ShouldEqual 'true'/g" \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml" \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-preflight.yaml"

                # TODO: [BUG] Fix Connectors URL in preflight tests - remove when upstream chart is fixed
                echo "Patch Connectors URLs in preflight variables using yq"

                # Get the connectors context path from assembled values, default to /connectors
                CONNECTORS_CONTEXT_PATH="/connectors"
                if [[ -f "camunda-assembled-values.yml" ]]; then
                  CONNECTORS_CONTEXT_PATH=$(yq '.connectors.contextPath // "/connectors"' camunda-assembled-values.yml)
                elif [[ -f "../camunda-assembled-values.yml" ]]; then
                  CONNECTORS_CONTEXT_PATH=$(yq '.connectors.contextPath // "/connectors"' ../camunda-assembled-values.yml)
                elif [[ -f "../../camunda-assembled-values.yml" ]]; then
                  CONNECTORS_CONTEXT_PATH=$(yq '.connectors.contextPath // "/connectors"' ../../camunda-assembled-values.yml)
                fi

                echo "Using Connectors context path: $CONNECTORS_CONTEXT_PATH"

                # Debug: Show current connectors URLs before patching
                echo "üîç DEBUG: Connectors URLs BEFORE patching in variables-default.yaml:"
                yq '.preflightVars.baseURLs.connectors // "NOT FOUND"' "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"

                echo "üîç DEBUG: Connectors URLs BEFORE patching in variables-ingress-combined.yaml:"
                yq '.preflightVars.baseURLs.connectors // "NOT FOUND"' "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"
                yq '.coreVars.baseURLs.connectors // "NOT FOUND"' "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"

                # Patch variables-default.yaml:
                # preflightVars: ensure /connectors (actuator endpoints need it)
                # coreVars: ensure /connectors/inbound (webhook endpoints)
                echo "Patching variables-default.yaml - fixing connectors URLs"

                # Fix preflightVars: add /connectors if missing (actuator endpoints are under /connectors/actuator/*)
                yq eval '.preflightVars.baseURLs.connectors |= (. | select(. | test("/connectors$") | not) | . + "/connectors") // .' \
                  -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"

                # Fix coreVars in variables-default.yaml (same logic as ingress)
                yq eval '.coreVars.baseURLs.connectors |= sub("/connectors/inbound/connectors$", "/connectors/inbound")' \
                  -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"
                yq eval '.coreVars.baseURLs.connectors |= sub("([^s])/inbound$", "$1/connectors/inbound")' \
                  -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"
                yq eval '.coreVars.baseURLs.connectors |= (. | select(. | test("/connectors$")) | . + "/inbound") // .' \
                  -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"
                yq eval '.coreVars.baseURLs.connectors |= (. | select(. | test("/connectors|/inbound") | not) | . + "/connectors/inbound") // .' \
                  -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"

                # Patch variables-ingress-combined.yaml: Fix preflightVars.baseURLs.connectors
                # preflightVars: ensure /connectors (actuator endpoints need it)
                # coreVars: ensure /connectors/inbound (webhook endpoints)
                echo "Patching variables-ingress-combined.yaml - ensuring /connectors for preflight URLs"

                # Fix preflightVars: add /connectors if missing (actuator endpoints are under /connectors/actuator/*)
                yq eval '.preflightVars.baseURLs.connectors |= (. | select(. | test("/connectors$") | not) | . + "/connectors") // .' \
                  -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"

                # Ensure coreVars have the correct context path for webhook endpoints
                # coreVars need the full path: /connectors/inbound (not just /connectors)
                echo "Ensuring coreVars have correct path for webhook endpoints"

                # Fix coreVars connectors URL: should have /connectors/inbound for webhooks
                # Step 1: Fix double /connectors issue
                yq eval '.coreVars.baseURLs.connectors |= sub("/connectors/inbound/connectors$", "/connectors/inbound")' \
                  -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"

                # Step 2: Fix /inbound without /connectors prefix
                yq eval '.coreVars.baseURLs.connectors |= sub("([^s])/inbound$", "$1/connectors/inbound")' \
                  -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"

                # Step 3: Add /inbound if missing (only /connectors)
                yq eval '.coreVars.baseURLs.connectors |= (. | select(. | test("/connectors$")) | . + "/inbound") // .' \
                  -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"

                # Step 4: Add /connectors/inbound if no context path at all
                yq eval '.coreVars.baseURLs.connectors |= (. | select(. | test("/connectors|/inbound") | not) | . + "/connectors/inbound") // .' \
                  -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"

                # Debug: Show URLs after patching
                echo "üîç DEBUG: Connectors URLs AFTER patching in variables-ingress-combined.yaml:"
                yq '.preflightVars.baseURLs.connectors' \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"
                yq '.coreVars.baseURLs.connectors' \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"

                # Patch playwright variables-ingress-combined.yaml similarly
                PLAYWRIGHT_VARS="$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/playwright/files/variables-ingress-combined.yaml"
                if [[ -f "$PLAYWRIGHT_VARS" ]]; then
                  echo "Patching playwright variables-ingress-combined.yaml"

                  # Fix preflightVars: add /connectors if missing (actuator endpoints are under /connectors/actuator/*)
                  yq eval '.preflightVars.baseURLs.connectors |= (. | select(. | test("/connectors$") | not) | . + "/connectors") // .' -i "$PLAYWRIGHT_VARS"

                  # For coreVars: apply same four-step fix
                  yq eval '.coreVars.baseURLs.connectors |= sub("/connectors/inbound/connectors$", "/connectors/inbound")' -i "$PLAYWRIGHT_VARS"
                  yq eval '.coreVars.baseURLs.connectors |= sub("([^s])/inbound$", "$1/connectors/inbound")' -i "$PLAYWRIGHT_VARS"
                  yq eval '.coreVars.baseURLs.connectors |= (. | select(. | test("/connectors$")) | . + "/inbound") // .' -i "$PLAYWRIGHT_VARS"
                  yq eval '.coreVars.baseURLs.connectors |= (. | select(. | test("/connectors|/inbound") | not) | . + "/connectors/inbound") // .' -i "$PLAYWRIGHT_VARS"
                fi

                echo "‚úÖ Connectors URL patches applied successfully with yq"

                if [[ "$ELASTICSEARCH_ENABLED" != "true" ]]; then
                  echo "Disable Elasticsearch in the core tests as it's not enabled"

                  yq eval 'del(.. | select(has("component") and .component == "Elasticsearch"))' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-preflight.yaml"
                fi

                if [ "$WEBMODELER_ENABLED" != "true" ]; then
                  echo "Disable Webmodeler in the core tests as it's not enabled"

                  echo "VENOM_VAR_SKIP_TEST_WEBMODELER=false" >> "$VARIABLES_ENV_FILE"
                  yq eval 'del(.. | select(has("component") and .component == "WebModeler"))' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml"
                fi

                # TODO: Fix later for Console and re-investigate
                # Tests are failing for some reason with no-domain, can't replicate locally
                # Assumption is that the jwt issuer is different in the test than expected
                # Disabling for now for no-domain setups
                if [[ "$CONSOLE_ENABLED" != "true" || "$CAMUNDA_DOMAIN" == "" ]]; then
                  echo "Disable Console in the core tests as it's not enabled"

                  yq eval 'del(.. | select(has("component") and .component == "Console"))' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml"
                fi

                echo "Patch the identity secrets to allow venom to access to the platform"
                sed -i -e 's/integration-test-credentials/identity-secret-for-components/g' \
                        "$TEST_CHART_DIR_STATIC/test/integration/testsuites/core/patches/job.yaml"

                # remove venom var client secret as we define it in the file
                yq e 'del(.spec.template.spec.containers[].env[] | select(.name == "VENOM_VAR_TEST_CLIENT_SECRET"))' \
                  -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/core/patches/job.yaml"

                # we're overwriting the tool-versions of the Helm chart tests with our own
                echo "Ensure asdf tool is available in the test suite by using our global one"
                cp .tool-versions "$TESTS_CAMUNDA_HELM_CHART_REPO_PATH"
              fi

        - name: üé≠ TESTS - Setup Playwright Environment
          if: ${{ inputs.enable-playwright-tests == 'true' }}
          shell: bash
          run: |
              set -euo pipefail

              if [[ -z "${PLAYWRIGHT_TEST_DIR:-}" ]]; then
                echo "‚ùå Playwright test directory not found, skipping Playwright tests"
                exit 0
              fi

              echo "Setting up Playwright environment in: $PLAYWRIGHT_TEST_DIR"
              cd "$PLAYWRIGHT_TEST_DIR"

              # Set component-specific tokens or use default
              CONNECTORS_TOKEN="${{ inputs.connectors-client-secret }}"
              OPTIMIZE_TOKEN="${{ inputs.optimize-client-secret }}"
              ORCHESTRATION_TOKEN="${{ inputs.orchestration-client-secret }}"
              ADMIN_TOKEN="${{ inputs.admin-client-secret }}"

              # Create .env file for Playwright with required configurations
              cat > .env << EOF
              # Base URLs configuration
              CONSOLE_BASE_URL=http://${{ inputs.camunda-domain }}/console
              KEYCLOAK_BASE_URL=http://${{ inputs.camunda-domain }}/auth
              IDENTITY_BASE_URL=http://${{ inputs.camunda-domain }}/identity
              OPERATE_BASE_URL=http://${{ inputs.camunda-domain }}/operate
              OPTIMIZE_BASE_URL=http://${{ inputs.camunda-domain }}/optimize
              TASKLIST_BASE_URL=http://${{ inputs.camunda-domain }}/tasklist
              CONNECTORS_LOGIN_PATH=http://${{ inputs.camunda-domain }}/connectors
              ZEEBE_GATEWAY_GRPC=${{ inputs.camunda-domain-grpc || inputs.camunda-domain }}:443
              ZEEBE_GATEWAY_REST=http://${{ inputs.camunda-domain }}/zeebe

              # Authentication configuration
              AUTH_URL=http://${{ inputs.camunda-domain }}/auth/realms/camunda-platform/protocol/openid-connect/token
              TEST_CLIENT_ID=${{ inputs.test-client-id }}

              # Playwright variables for different clients
              PLAYWRIGHT_VAR_CONNECTORS_CLIENT_SECRET=$CONNECTORS_TOKEN
              PLAYWRIGHT_VAR_OPTIMIZE_CLIENT_SECRET=$OPTIMIZE_TOKEN
              PLAYWRIGHT_VAR_ORCHESTRATION_CLIENT_SECRET=$ORCHESTRATION_TOKEN
              PLAYWRIGHT_VAR_ADMIN_CLIENT_SECRET=$ADMIN_TOKEN

              # CI Configuration
              CI=true
              EOF

              # If no domain is provided, use localhost with port forwarding
              if [[ -z "${{ inputs.camunda-domain }}" ]]; then
                echo "No domain provided, configuring for localhost with port forwarding"
                cat > .env << EOF
              # Local development URLs (port-forwarded)
              CONSOLE_BASE_URL=http://localhost:8080/console
              KEYCLOAK_BASE_URL=http://localhost:18080/auth
              IDENTITY_BASE_URL=http://localhost:8080/identity
              OPERATE_BASE_URL=http://localhost:8080/operate
              OPTIMIZE_BASE_URL=http://localhost:8080/optimize
              TASKLIST_BASE_URL=http://localhost:8080/tasklist
              CONNECTORS_LOGIN_PATH=http://localhost:8080/connectors
              ZEEBE_GATEWAY_GRPC=localhost:26500
              ZEEBE_GATEWAY_REST=http://localhost:8080/zeebe

              # Authentication configuration
              AUTH_URL=http://localhost:18080/auth/realms/camunda-platform/protocol/openid-connect/token
              TEST_CLIENT_ID=${{ inputs.test-client-id }}

              # Playwright variables
              PLAYWRIGHT_VAR_CONNECTORS_CLIENT_SECRET=$CONNECTORS_TOKEN
              PLAYWRIGHT_VAR_OPTIMIZE_CLIENT_SECRET=$OPTIMIZE_TOKEN
              PLAYWRIGHT_VAR_ORCHESTRATION_CLIENT_SECRET=$ORCHESTRATION_TOKEN
              PLAYWRIGHT_VAR_ADMIN_CLIENT_SECRET=$ADMIN_TOKEN

              # CI Configuration
              CI=true
              EOF
              fi

              # Install dependencies if package.json exists
              if [[ -f "package.json" ]]; then
                echo "Installing Playwright dependencies..."
                npm ci
                echo "Installing Playwright browsers..."
                npx playwright install --with-deps
              else
                echo "‚ö†Ô∏è No package.json found in Playwright test directory"
              fi

        - name: üß™ TESTS - Run Preflight TestSuite
          if: ${{ inputs.enable-helm-chart-tests == 'true' }}
          shell: bash
          run: |
              set -euo pipefail

              task -d "${CI_TASKS_BASE_DIR}/chart-full-setup" test.preflight

        - name: üß™ TESTS - Run Core TestSuite
          if: ${{ inputs.enable-helm-chart-tests == 'true' }}
          shell: bash
          run: |
              set -euo pipefail

              task -d "${CI_TASKS_BASE_DIR}/chart-full-setup" test.core

        - name: üé≠ TESTS - Run Playwright Tests
          if: ${{ inputs.enable-playwright-tests == 'true' }}
          shell: bash
          env:
              DOMAIN_NAME: ${{ inputs.camunda-domain }}
              CAMUNDA_RELEASE_NAME: ${{ inputs.test-release-name }}
          run: |
              set -euo pipefail

              if [[ -z "${PLAYWRIGHT_TEST_DIR:-}" ]]; then
                echo "‚ùå Playwright test directory not found, skipping Playwright tests"
                exit 0
              fi

              echo "Running Playwright tests from: $PLAYWRIGHT_TEST_DIR"
              cd "$PLAYWRIGHT_TEST_DIR"

              # Function to help with port-forwarding for Playwright tests when no domain is provided
              start_port_forward_playwright() {
                  local service=$1
                  local ports=$2
                  kubectl port-forward service/$service $ports -n $TEST_NAMESPACE >/dev/null 2>&1 &
                  local pid=$!
                  PLAYWRIGHT_PORT_FORWARD_PIDS+=($pid)
                  echo "Port-forwarding for Playwright - $service on ports $ports started."
              }

              cleanup_playwright() {
                for pid in "${PLAYWRIGHT_PORT_FORWARD_PIDS[@]}"; do
                  echo "üõë Stopping Playwright port-forward (PID: $pid)..."
                  kill "$pid" 2>/dev/null || echo "‚ö†Ô∏è Failed to kill PID $pid"
                done
              }

              trap cleanup_playwright EXIT

              PLAYWRIGHT_PORT_FORWARD_PIDS=()

              # Setup port forwarding if no domain is provided
              if [[ -z "$DOMAIN_NAME" ]]; then
                echo "Setting up port forwarding for Playwright tests..."

                # Use configurable Keycloak service name or fallback to default pattern
                KEYCLOAK_SERVICE_INPUT="${{ inputs.keycloak-service-name }}"
                if [[ -z "$KEYCLOAK_SERVICE_INPUT" ]]; then
                  KEYCLOAK_SERVICE_NAME="${CAMUNDA_RELEASE_NAME}-keycloak"
                  KEYCLOAK_SERVICE_PORT="80"
                else
                  if [[ "$KEYCLOAK_SERVICE_INPUT" == *":"* ]]; then
                    KEYCLOAK_SERVICE_NAME="${KEYCLOAK_SERVICE_INPUT%:*}"
                    KEYCLOAK_SERVICE_PORT="${KEYCLOAK_SERVICE_INPUT#*:}"
                  else
                    KEYCLOAK_SERVICE_NAME="$KEYCLOAK_SERVICE_INPUT"
                    KEYCLOAK_SERVICE_PORT="80"
                  fi
                fi

                # Start port forwarding for services
                start_port_forward_playwright "${CAMUNDA_RELEASE_NAME}-zeebe-gateway" 8080:8080
                start_port_forward_playwright "${CAMUNDA_RELEASE_NAME}-zeebe-gateway" 26500:26500
                start_port_forward_playwright "$KEYCLOAK_SERVICE_NAME" "18080:$KEYCLOAK_SERVICE_PORT"

                echo "Waiting for port-forwarding to be established..." && sleep 15
              fi

              # Run Playwright tests
              echo "üé≠ Running Playwright test suite: ${{ inputs.playwright-test-suite }}"

              # Check if we should run a specific project or all tests
              if [[ "${{ inputs.playwright-test-suite }}" == "smoke-tests" ]]; then
                npx playwright test --project=smoke-tests --reporter=html,junit
              elif [[ "${{ inputs.playwright-test-suite }}" == "full-suite" ]]; then
                npx playwright test --project=full-suite --reporter=html,junit
              else
                echo "Running all Playwright tests..."
                npx playwright test --reporter=html,junit
              fi

        - name: üß™ TESTS - Run zeebe client tests
          if: ${{ inputs.enable-zeebe-client-tests == 'true' }}
          shell: bash
          env:
              DOMAIN_NAME: ${{ inputs.camunda-domain }}
              CLUSTER_2_NAME: ${{ inputs.cluster-2-name || '' }}
              CAMUNDA_NAMESPACE_2: ${{ inputs.camunda-namespace-2 || '' }}
              CAMUNDA_NAMESPACE_1: ${{ inputs.camunda-namespace-1 || '' }}
              CAMUNDA_RELEASE_NAME: ${{ inputs.test-release-name || '' }}
          run: |
              set -euo pipefail

              reference_file="${{ inputs.zeebe-topology-golden-file }}"
              topology_check_script="${{ inputs.zeebe-topology-check-script }}"
              zeebe_authenticated="${{ inputs.zeebe-authenticated }}"

              echo "Using golden reference file to compare against: $reference_file"
              echo "Using topology check script: $topology_check_script"

              if [[ "$zeebe_authenticated" == "true" ]]; then
                echo "Using authenticated Zeebe client credentials..."
                export ZEEBE_CLIENT_ID="${{ inputs.test-client-id }}"

                # Use orchestration-specific token if provided, otherwise fallback to default
                ORCHESTRATION_TOKEN="${{ inputs.orchestration-client-secret }}"

                export ZEEBE_CLIENT_SECRET="$ORCHESTRATION_TOKEN"
              fi

              # function to help with port-forwarding in the background
              start_port_forward() {
                  local service=$1
                  local ports=$2
                  kubectl port-forward service/$service $ports -n $TEST_NAMESPACE >/dev/null 2>&1 &
                  local pid=$!
                  PORT_FORWARD_PIDS+=($pid)
                  echo "Port-forwarding for $service on ports $ports started."
              }

              cleanup() {
                for pid in "${PORT_FORWARD_PIDS[@]}"; do
                  echo "üõë Stopping port-forward (PID: $pid)..."
                  kill "$pid" 2>/dev/null || echo "‚ö†Ô∏è Failed to kill PID $pid"
                done
              }

              trap cleanup EXIT

              PORT_FORWARD_PIDS=()

              # Dual-Region includes the portforwarding itself, therefore skipping it here
              if [[ -z "$DOMAIN_NAME" && -z "$CLUSTER_2_NAME" ]]; then
                # Without domain:
                source ./generic/kubernetes/single-region/procedure/export-verify-zeebe-local.sh

                # Use configurable Keycloak service name or fallback to default pattern
                KEYCLOAK_SERVICE_INPUT="${{ inputs.keycloak-service-name }}"

                if [[ -z "$KEYCLOAK_SERVICE_INPUT" ]]; then
                  KEYCLOAK_SERVICE_NAME="${CAMUNDA_RELEASE_NAME}-keycloak"
                  KEYCLOAK_SERVICE_PORT="80"  # Default port for Helm-based services
                else
                  # Parse service name and port from input (same logic as above)
                  if [[ "$KEYCLOAK_SERVICE_INPUT" == *":"* ]]; then
                    KEYCLOAK_SERVICE_NAME="${KEYCLOAK_SERVICE_INPUT%:*}"  # Extract service name
                    KEYCLOAK_SERVICE_PORT="${KEYCLOAK_SERVICE_INPUT#*:}"  # Extract port
                  else
                    KEYCLOAK_SERVICE_NAME="$KEYCLOAK_SERVICE_INPUT"
                    KEYCLOAK_SERVICE_PORT="80"  # Default port if not specified
                  fi
                fi

                echo "Using Keycloak service: $KEYCLOAK_SERVICE_NAME:$KEYCLOAK_SERVICE_PORT"

                start_port_forward "${CAMUNDA_RELEASE_NAME}-zeebe-gateway" 8080:8080

                # Setup Keycloak port-forwarding with dynamic port
                start_port_forward "$KEYCLOAK_SERVICE_NAME" "18080:$KEYCLOAK_SERVICE_PORT"

                echo "Waiting for port-forwarding to be established..." && sleep 10
              else
                # With domain:
                source ./generic/kubernetes/single-region/procedure/export-verify-zeebe-domain.sh
              fi

              # Execute the script and capture the output in a variable
              eval "$topology_check_script"
              check_zeebe_topology_output=$(<zeebe-topology.json)

              # Checks
              error_found=false
              check_zeebe_topology_all_healthy=$(echo "$check_zeebe_topology_output" | jq '[.brokers[].partitions[].health == "healthy"] | all')
              check_zeebe_topology_cluster_size=$(echo "$check_zeebe_topology_output" | jq '.clusterSize')
              check_zeebe_topology_partitions_count=$(echo "$check_zeebe_topology_output" | jq '.partitionsCount')

              golden_zeebe_topology_cluster_size=$(jq '.clusterSize' < "$reference_file")
              golden_zeebe_topology_partitions_count=$(jq '.partitionsCount' < "$reference_file")

              if [ "$check_zeebe_topology_all_healthy" = "true" ]; then
                echo "‚úÖ All partitions are healthy."
              else
                echo "‚ùå Not all partitions are healthy"
                error_found=true
              fi

              if [ "$check_zeebe_topology_cluster_size" -eq $golden_zeebe_topology_cluster_size ]; then
                echo "‚úÖ Cluster size is $check_zeebe_topology_cluster_size."
              else
                echo "‚ùå Cluster size is not $golden_zeebe_topology_cluster_size."
                error_found=true
              fi

              if [ "$check_zeebe_topology_partitions_count" -eq $golden_zeebe_topology_partitions_count ]; then
                echo "‚úÖ Partitions count is $check_zeebe_topology_partitions_count."
              else
                echo "‚ùå Partitions count is not $golden_zeebe_topology_partitions_count."
                error_found=true
              fi

              echo "Comparing golden file of the zeebe topology output..."

              # Save the output to a temporary file
              temp_output=$(mktemp)
              echo "$check_zeebe_topology_output" > "$temp_output"

              # Replace patch version
              yq e '.brokers[].version |= sub("[.].*$", ".z") | .gatewayVersion |= sub("[.].*$", ".z")' -i "$temp_output"
              yq e '.brokers[].version |= sub("[.].*$", ".z") | .gatewayVersion |= sub("[.].*$", ".z")' -i "$reference_file"

              # Replace namespace names with cluster names if env vars are set
              if [[ -n "${CLUSTER_2_NAME:-}" && -n "${CAMUNDA_NAMESPACE_2:-}" && -n "${CAMUNDA_NAMESPACE_1:-}" ]]; then
                echo "Replacing namespace values in golden file..."
                sed -e "s/cluster-region-2/$CLUSTER_2_NAME/g" \
                    -e "s/camunda-cluster-region-2\.svc/$CAMUNDA_NAMESPACE_2\.svc/g" \
                    -e "s/camunda-cluster-region-1\.svc/$CAMUNDA_NAMESPACE_1\.svc/g" \
                    -i "$reference_file"
              fi

              echo "Replacing release name value in golden file..."
              sed -e "s/camunda-zeebe/${CAMUNDA_RELEASE_NAME}-zeebe/g" -i "$reference_file"

              # Order each file also remove not predictable fields
              yq e '.brokers |= sort_by(.host) | .brokers[] |= (.partitions |= sort_by(.partitionId) | .partitions[].role = "NOT_PREDICTABLE")' -i "$temp_output"
              yq e '.brokers |= sort_by(.host) | .brokers[] |= (.partitions |= sort_by(.partitionId) | .partitions[].role = "NOT_PREDICTABLE")' -i "$reference_file"

              # Compare the two files using diff (in compacted JSON format)
              diff_output=$(delta <(jq -S . "$temp_output") <(jq -S . "$reference_file") || true)

              if [[ -n "$diff_output" ]]; then
                # If differences are found, print the error and the diff
                echo "‚ùå Error: The golden files of zeebe topology files do not match."
                echo "Differences found:"
                echo "$diff_output"

                # Display the new generated version
                echo "New version:"
                cat "$temp_output"

                error_found=true
              fi

              if [ "$error_found" = true ]; then
                echo "‚ùå Some tests failed."
                exit 1
              fi
              echo "‚úÖ The cluster meets all the expected criteria."

        - name: üìä Upload Playwright Results
          if: ${{ always() && inputs.enable-playwright-tests == 'true' }}
          uses: actions/upload-artifact@v4
          with:
              name: playwright-results
              path: |
                  ${{ env.PLAYWRIGHT_TEST_DIR }}/playwright-report/
                  ${{ env.PLAYWRIGHT_TEST_DIR }}/test-results/
              retention-days: 7
