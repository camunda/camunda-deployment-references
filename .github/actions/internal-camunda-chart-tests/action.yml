---
name: Camunda Chart Tests

description: >
    Run the Camunda Helm chart tests.
    Already requires the Helm chart to be deployed and cluster access granted.

    This action integrates multiple testing layers:
    1. Helm chart integration tests (Venom-based, from camunda-platform-helm)
    2. C8 Self-Managed checks (from c8-sm-checks repository):
       - Deployment verification (checks pods and containers status)
       - Kubernetes connectivity checks (services and ingress resolution)
       - AWS IRSA configuration checks (for EKS clusters with IRSA)
       - Zeebe token generation and connectivity checks
    3. Helm Playwright integration tests (optional, from camunda-platform-helm):
       - Service connectivity tests (Identity, Console, Operate, etc.)
       - Authentication flow tests (Keycloak, Basic, Hybrid)
       - API and gRPC connectivity tests

    All checks can be individually enabled/disabled via inputs.

inputs:
    tests-camunda-helm-chart-repo-ref:
        description: The branch, tag or commit to checkout
        default: main
    tests-camunda-helm-chart-repo-path:
        description: Path to the Helm chart repository
        default: ./.camunda_helm_repo
    tests-c8-sm-checks-repo-ref:
        description: The branch, tag or commit to checkout for c8-sm-checks
        default: main
    tests-c8-sm-checks-repo-path:
        description: Path to clone the c8-sm-checks repository
        default: ./.c8-sm-checks
    secrets:
        description: JSON wrapped secrets for easier secret passing
        required: true
    camunda-version:
        description: The version of the Camunda to test
        required: true
    camunda-domain:
        description: The domain to use for the tests
        default: ''
    camunda-domain-grpc:
        description: The domain to use for the gRPC tests
        default: ''
    webmodeler-enabled:
        description: Whether the Webmodeler is enabled in the chart
        default: 'false'
    console-enabled:
        description: Whether the Console is enabled in the chart
        default: 'false'
    elasticsearch-enabled:
        description: Whether the Elasticsearch is enabled in the chart
        default: 'true'
    test-namespace:
        description: The namespace to use for the helm tests
        default: camunda
    test-release-name:
        description: The helm release name to used for by the helm tests
        default: camunda
    test-cluster-type:
        description: The type of the cluster to use for the tests
        default: kubernetes
    zeebe-topology-golden-file:
        description: The golden file to compare the Zeebe topology output against.
        default: ./generic/kubernetes/single-region/procedure/check-zeebe-cluster-topology-output.json
    zeebe-topology-check-script:
        description: The script called to the current Zeebe topology.
        default: ./generic/kubernetes/single-region/procedure/check-zeebe-cluster-topology.sh
    zeebe-authenticated:
        description: Use the authentication layer to interact with zeebe
        default: 'true'
    enable-helm-chart-tests:
        description: Whether the Helm Chart tests should be run
        default: 'true'
    enable-zeebe-client-tests:
        description: Whether the Zeebe Client tests should be run
        default: 'true'
    cluster-2-name:
        description: Optional cluster 2 name for sed replacement (dual-region only)
        required: false
    camunda-namespace-2:
        description: Optional namespace for region 2 (dual-region only)
        required: false
    camunda-namespace-1:
        description: Optional namespace for region 1 (dual-region only)
        required: false
    keycloak-service-name:
        description: Name of the Keycloak service with optional port (e.g. keycloak-service:8080)
        default: ''  # Will use ${CAMUNDA_RELEASE_NAME}-keycloak:8080 by default
    elasticsearch-service-name:
        description: Name of the Elasticsearch service with optional port (e.g. elasticsearch-es-http:9200)
        default: ''  # Will use ${CAMUNDA_RELEASE_NAME}-elasticsearch by default
    test-client-id:
        description: Client ID for Camunda authentication tests
        required: true
    test-client-secret:
        description: Client secret for Camunda authentication tests
        required: true
    enable-c8sm-deployment-check:
        description: Whether the C8 SM deployment check should be run
        default: 'true'
    enable-c8sm-connectivity-check:
        description: Whether the C8 SM Kubernetes connectivity check should be run
        default: 'true'
    skip-c8sm-connectivity-ingress-class-check:
        description: Whether to skip the ingress class check part of the C8 SM Kubernetes connectivity check
        default: 'false'
    enable-c8sm-irsa-check:
        description: Whether the C8 SM AWS IRSA check should be run (only applicable for EKS)
        default: 'false'
    enable-c8sm-zeebe-token-check:
        description: Whether the C8 SM Zeebe token generation check should be run
        default: 'true'
    enable-c8sm-zeebe-connectivity-check:
        description: Whether the C8 SM Zeebe connectivity check should be run
        default: 'true'
    local-domain-mode:
        description: >
            Enable local domain mode. When true, /etc/hosts entries will be added
            to resolve camunda.example.com and zeebe-camunda.example.com to 127.0.0.1.
            This is required for local Kind clusters with domain-based access where
            the runner needs to access the ingress via localhost.
        default: 'false'
    local-domain-ip:
        description: >
            The IP address to use for local domain resolution in /etc/hosts.
            Defaults to 127.0.0.1 for standard local development.
        default: 127.0.0.1
    enable-helm-playwright-tests:
        description: >
            Whether to run the Helm chart Playwright integration tests.
            These tests run against the deployed Camunda platform and test
            service connectivity, authentication, and basic functionality.
        default: 'false'
    helm-playwright-test-auth-type:
        description: >
            Authentication type for Helm Playwright tests.
            Options: keycloak, basic, hybrid
            - keycloak: Use Keycloak/OIDC authentication for all tests
            - basic: Use basic auth (demo:demo) for all tests
            - hybrid: Run OIDC tests (identity, console) with keycloak, then basic auth tests (connectors, core-rest, core-grpc)
        default: keycloak
    helm-playwright-test-project:
        description: >
            Playwright test project to run.
            Options: full-suite, smoke-tests
            - full-suite: Run all integration tests
            - smoke-tests: Run only smoke tests (faster, for quick validation)
        default: smoke-tests
    helm-playwright-test-exclude:
        description: >
            Test suites to exclude from Helm Playwright tests.
            Example: 'identity.spec.ts' or 'console.spec.ts|identity.spec.ts'
        default: ''
    helm-playwright-orchestration-context-path:
        description: >
            Orchestration context path used by the Camunda deployment.
            This maps to the ORCHESTRATION_CONTEXT_PATH env var used by Playwright tests
            for navigating to Tasklist, Operate, and OC Identity.
            Defaults to empty string (apps served at /, e.g. /tasklist, /operate).
        default: ''
    helm-playwright-identity-context-path:
        description: >
            Management Identity context path used by the Camunda deployment.
            This maps to the MANAGEMENT_IDENTITY_CONTEXT_PATH env var used by Playwright tests.
            Must match the identity.contextPath value in the Helm values.
        default: /managementidentity
    helm-playwright-firstuser-secret-name:
        description: >
            Name of the Kubernetes secret containing the Identity first user password.
            For auto-generated secrets (Kind), use 'camunda-credentials'.
            For manually provisioned secrets (EKS/AKS), use the appropriate secret name.
        default: camunda-credentials
    helm-playwright-firstuser-secret-key:
        description: >
            Key within the first user secret that contains the password.
        default: identity-first-user-password
    helm-playwright-keycloak-secret-name:
        description: >
            Name of the Kubernetes secret containing the Keycloak admin password.
        default: keycloak-initial-admin
    helm-playwright-keycloak-secret-key:
        description: >
            Key within the Keycloak secret that contains the admin password.
        default: password
    helm-playwright-firstuser-username:
        description: >
            The username of the Camunda identity first user used for Playwright authentication.
        default: admin
    helm-playwright-keycloak-username:
        description: >
            The Keycloak admin username used by Playwright tests to manage test users.
            This is the username stored in the keycloak-initial-admin secret by the Keycloak operator.
        default: temp-admin
    helm-playwright-upload-artifacts:
        description: Whether to upload Playwright test artifacts on failure
        default: 'true'
    helm-playwright-artifact-retention-days:
        description: Number of days to retain Playwright test artifacts
        default: '10'

runs:
    using: composite
    steps:
        - name: Import Secrets
          id: secrets
          if: ${{ inputs.enable-helm-chart-tests == 'true' || inputs.zeebe-authenticated == 'true' || inputs.enable-helm-playwright-tests == 'true' }}
          uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3
          with:
              url: ${{ fromJSON(inputs.secrets).VAULT_ADDR }}
              method: approle
              roleId: ${{ fromJSON(inputs.secrets).VAULT_ROLE_ID }}
              secretId: ${{ fromJSON(inputs.secrets).VAULT_SECRET_ID }}
              exportEnv: false
              secrets: |
                  secret/data/products/infrastructure-experience/ci/common DOCKERHUB_USER;
                  secret/data/products/infrastructure-experience/ci/common DOCKERHUB_PASSWORD;

        - name: üßô‚Äç‚ôÇÔ∏è Clone camunda/camunda-platform-helm
          uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
          if: ${{ inputs.enable-helm-chart-tests == 'true' || inputs.enable-helm-playwright-tests == 'true' }}
          with:
              repository: camunda/camunda-platform-helm
              ref: ${{ inputs.tests-camunda-helm-chart-repo-ref }}
              path: ${{ inputs.tests-camunda-helm-chart-repo-path }}
              fetch-depth: 0

        - name: üßô‚Äç‚ôÇÔ∏è Clone camunda/c8-sm-checks
          uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
          with:
              repository: camunda/c8-sm-checks
              ref: ${{ inputs.tests-c8-sm-checks-repo-ref }}
              path: ${{ inputs.tests-c8-sm-checks-repo-path }}
              fetch-depth: 0

        - name: üìã Display C8-SM-CHECKS Configuration
          shell: bash
          run: |
              set -euo pipefail

              echo "======================================"
              echo "C8 Self-Managed Checks Configuration"
              echo "======================================"
              echo ""
              echo "Tests enabled:"
              echo "  - Deployment Check: ${{ inputs.enable-c8sm-deployment-check }}"
              echo "  - Kubernetes Connectivity Check: ${{ inputs.enable-c8sm-connectivity-check }}"
              echo "  - AWS IRSA Check: ${{ inputs.enable-c8sm-irsa-check }}"
              echo "  - Zeebe Token Generation Check: ${{ inputs.enable-c8sm-zeebe-token-check }}"
              echo "  - Zeebe Connectivity Check: ${{ inputs.enable-c8sm-zeebe-connectivity-check }}"
              echo ""
              echo "Configuration:"
              echo "  - Namespace: ${{ inputs.test-namespace }}"
              echo "  - Release Name: ${{ inputs.test-release-name }}"
              echo "  - Cluster Type: ${{ inputs.test-cluster-type }}"
              echo "  - Domain: ${{ inputs.camunda-domain || '(not configured)' }}"
              echo "  - WebModeler Enabled: ${{ inputs.webmodeler-enabled }}"
              echo "  - Console Enabled: ${{ inputs.console-enabled }}"
              echo "  - Elasticsearch Enabled: ${{ inputs.elasticsearch-enabled }}"
              echo ""
              echo "======================================"

        - name: üîß Configure service references
          shell: bash
          env:
              CAMUNDA_RELEASE_NAME: ${{ inputs.test-release-name }}
          run: |
              set -euo pipefail

              # Configure Keycloak service reference
              KEYCLOAK_SERVICE_INPUT="${{ inputs.keycloak-service-name }}"
              KEYCLOAK_TARGET="${KEYCLOAK_SERVICE_INPUT:-${CAMUNDA_RELEASE_NAME}-keycloak:8080}"

              # Configure Elasticsearch service reference
              ELASTICSEARCH_SERVICE_INPUT="${{ inputs.elasticsearch-service-name }}"
              ELASTICSEARCH_TARGET="${ELASTICSEARCH_SERVICE_INPUT:-${CAMUNDA_RELEASE_NAME}-elasticsearch:9200}"

              # Export service configurations for subsequent steps
              echo "KEYCLOAK_TARGET=$KEYCLOAK_TARGET" | tee -a "$GITHUB_ENV"
              echo "ELASTICSEARCH_TARGET=$ELASTICSEARCH_TARGET" | tee -a "$GITHUB_ENV"

        - name: üß™ TESTS - Set variables
          if: ${{ inputs.enable-helm-chart-tests == 'true' }}
          shell: bash
          env:
              CAMUNDA_VERSION: ${{ inputs.camunda-version }}
              CAMUNDA_DOMAIN: ${{ inputs.camunda-domain }}
              CAMUNDA_DOMAIN_GRPC: ${{ inputs.camunda-domain-grpc }}
              WEBMODELER_ENABLED: ${{ inputs.webmodeler-enabled }}
              CONSOLE_ENABLED: ${{ inputs.console-enabled }}
              ELASTICSEARCH_ENABLED: ${{ inputs.elasticsearch-enabled }}
          run: |
              set -euo pipefail

              # export test variables to be used in other steps
              echo "TEST_NAMESPACE=${{ inputs.test-namespace }}" | tee -a "$GITHUB_ENV"
              echo "TEST_CHART_NAME=${{ inputs.test-release-name }}" | tee -a "$GITHUB_ENV"
              echo "TEST_CLUSTER_TYPE=$TEST_CLUSTER_TYPE" | tee -a "$GITHUB_ENV"
              export TESTS_CAMUNDA_HELM_CHART_REPO_PATH="${{ inputs.tests-camunda-helm-chart-repo-path }}"
              echo "TESTS_CAMUNDA_HELM_CHART_REPO_PATH=$TESTS_CAMUNDA_HELM_CHART_REPO_PATH" | tee -a "$GITHUB_ENV"

              export TEST_CHART_DIR_STATIC="$TESTS_CAMUNDA_HELM_CHART_REPO_PATH/charts/camunda-platform-$CAMUNDA_VERSION"
              echo "TEST_CHART_DIR_STATIC=$TEST_CHART_DIR_STATIC" | tee -a "$GITHUB_ENV"

              TEST_INGRESS_HOST="$CAMUNDA_DOMAIN"
              echo "TEST_INGRESS_HOST=$TEST_INGRESS_HOST" | tee -a "$GITHUB_ENV"

              # shellcheck disable=SC2002
              TEST_CHART_VERSION=$(cat "$TEST_CHART_DIR_STATIC/Chart.yaml" | yq '.version')
              echo "TEST_CHART_VERSION=$TEST_CHART_VERSION" | tee -a "$GITHUB_ENV"

              # setup docker registry secret for tests
              echo "TEST_CREATE_DOCKER_LOGIN_SECRET=true" | tee -a "$GITHUB_ENV"
              echo "TEST_DOCKER_USERNAME_CAMUNDA_CLOUD=${{ steps.secrets.outputs.DOCKERHUB_USER }}" | tee -a "$GITHUB_ENV"
              echo "TEST_DOCKER_PASSWORD_CAMUNDA_CLOUD=${{ steps.secrets.outputs.DOCKERHUB_PASSWORD }}" | tee -a "$GITHUB_ENV"

              CI_TASKS_BASE_DIR="$TESTS_CAMUNDA_HELM_CHART_REPO_PATH/test/integration/scenarios/"
              echo "CI_TASKS_BASE_DIR=$CI_TASKS_BASE_DIR" | tee -a "$GITHUB_ENV"
              export TEST_CHART_DIR="../../../../charts/camunda-platform-$CAMUNDA_VERSION"
              echo "TEST_CHART_DIR=$TEST_CHART_DIR" | tee -a "$GITHUB_ENV"
              export TEST_VALUES_BASE_DIR="$TESTS_CAMUNDA_HELM_CHART_REPO_PATH/test/integration/scenarios"
              echo "TEST_VALUES_BASE_DIR=$TEST_VALUES_BASE_DIR" | tee -a "$GITHUB_ENV"

              # replace integration with the camunda release name as part of adaptation required to run the tests in our environment
              if [[ "${{ inputs.enable-helm-chart-tests }}" == "true" ]]; then
                find "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/" -type f -print0 | xargs -0 sed -i "s/integration/$CAMUNDA_RELEASE_NAME/g"

                # Use pre-configured service references from environment
                echo "Updating service references:"
                echo "  Keycloak: http://$KEYCLOAK_TARGET"
                echo "  Elasticsearch: http://$ELASTICSEARCH_TARGET"

                # Update variables-default.yaml (used for no-domain scenarios)
                yq eval ".preflightVars.baseURLs.keycloak = \"http://${KEYCLOAK_TARGET}\"" -i \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"
                yq eval ".preflightVars.baseURLs.elasticsearch = \"http://${ELASTICSEARCH_TARGET}\"" -i \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"
                yq eval ".coreVars.authURL = \"http://${KEYCLOAK_TARGET}/auth/realms/camunda-platform/protocol/openid-connect/token\"" -i \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"

                # Update variables-ingress-combined.yaml (used for domain/ingress scenarios)
                # For domain scenarios, keep the public HTTPS URLs, only update internal service references
                if [[ -f "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml" ]]; then
                  # Only update preflightVars (internal service checks) and elasticsearch
                  yq eval ".preflightVars.baseURLs.keycloak = \"http://${KEYCLOAK_TARGET}\"" -i \
                    "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"
                  yq eval ".preflightVars.baseURLs.elasticsearch = \"http://${ELASTICSEARCH_TARGET}\"" -i \
                    "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"
                  yq eval ".coreVars.baseURLs.elasticsearch = \"http://${ELASTICSEARCH_TARGET}\"" -i \
                    "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"
                  # DO NOT update coreVars.baseURLs.keycloak - it should use the public ingress URL (https://$DOMAIN/auth/)
                  echo "Note: Keycloak coreVars URL preserved for public ingress access"
                fi

                echo "‚úÖ Service references updated successfully"

                echo "Configure Venom tests"
                # (adapted from https://github.com/camunda/camunda-platform-helm/blob/test/integration/scenarios/chart-full-setup/Taskfile.yaml#L56)
                export VARIABLES_ENV_FILE="$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables.env"

                # False because we run OIDC
                echo "VENOM_VAR_SKIP_TEST_KEYCLOAK=false" >> "$VARIABLES_ENV_FILE"

                # Enable the ingress tests

                if [[ "$CAMUNDA_DOMAIN" != "" ]]; then
                  # shellcheck disable=SC2129
                  echo "VENOM_VAR_TEST_INGRESS_HOST=$TEST_INGRESS_HOST" >> "$VARIABLES_ENV_FILE"
                  echo "VENOM_EXTRA_ARGS=--var-from-file=./vars/variables-ingress-combined.yaml" >> "$VARIABLES_ENV_FILE"

                  # Setting is broken and results in always skipping ingress tests
                  # This removes the faulty setting but should only be done in domain context
                  echo "Skip test ingress is also broken, fixing it"
                  yq eval '(.testcases[].steps[].skip |= map(select(test("skiptestingress", "i") | not)))' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml"
                  yq eval 'del(.. | select(has("skip") and .skip | length == 0).skip)' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml"

                  if [[ "$CAMUNDA_DOMAIN_GRPC" != "" ]]; then
                    yq eval '.coreVars.baseURLs.orchestrationGRPC = env(CAMUNDA_DOMAIN_GRPC)' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"
                  fi
                else
                  # Some variables are not working correctly, patching it with yq directly
                  echo "VENOM_VAR_SKIP_TEST_INGRESS=true" >> "$VARIABLES_ENV_FILE"

                  # fix wrong default orchestrationGRPC port
                  yq eval '.coreVars.baseURLs.orchestrationGRPC |= (select(tag == "!!str") | sub("^http://", "") | sub(":9600$", ":26500"))' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"
                fi

                echo "VENOM_VAR_TEST_CLIENT_ID=${{ inputs.test-client-id }}" >> "$VARIABLES_ENV_FILE"
                echo "VENOM_VAR_TEST_CLIENT_SECRET=${{ inputs.test-client-secret }}" >> "$VARIABLES_ENV_FILE"

                ZEEBE_VERSION=$(yq '.zeebe.image.tag' "$TEST_CHART_DIR_STATIC/values.yaml")
                # shellcheck disable=SC2129
                echo "ZEEBE_VERSION=$ZEEBE_VERSION" >> "$VARIABLES_ENV_FILE"
                # In case the Zeebe version has not been released officially yet.
                echo "ZEEBE_VERSION_FALLBACK=8.5.6" >> "$VARIABLES_ENV_FILE"

                echo "Patch the test files..."

                # TODO: [BUG] remove the patchs when https://github.com/camunda/camunda-platform-helm/issues/3081 is fixed
                echo "Patch expression ShoudBeFalse"
                sed -i "s/ ShouldBeFalse/ ShouldEqual 'false'/g" \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml" \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-preflight.yaml"

                echo "Patch expression ShouldBeTrue"
                sed -i "s/ ShouldBeTrue/ ShouldEqual 'true'/g" \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml" \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-preflight.yaml"

                if [[ "$ELASTICSEARCH_ENABLED" != "true" ]]; then
                  echo "Disable Elasticsearch in the core tests as it's not enabled"

                  yq eval 'del(.. | select(has("component") and .component == "Elasticsearch"))' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-preflight.yaml"
                fi

                if [ "$WEBMODELER_ENABLED" != "true" ]; then
                  echo "Disable Webmodeler in the core tests as it's not enabled"

                  echo "VENOM_VAR_SKIP_TEST_WEBMODELER=false" >> "$VARIABLES_ENV_FILE"
                  yq eval 'del(.. | select(has("component") and .component == "WebModeler"))' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml"
                fi

                echo "Patch the identity secrets to allow venom to access to the platform"
                sed -i -e 's/integration-test-credentials/identity-secret-for-components/g' \
                        "$TEST_CHART_DIR_STATIC/test/integration/testsuites/core/patches/job.yaml"

                # remove venom var client secret as we define it in the file
                yq e 'del(.spec.template.spec.containers[].env[] | select(.name == "VENOM_VAR_TEST_CLIENT_SECRET"))' \
                  -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/core/patches/job.yaml"

                # we're overwriting the tool-versions of the Helm chart tests with our own
                echo "Ensure asdf tool is available in the test suite by using our global one"
                cp .tool-versions "$TESTS_CAMUNDA_HELM_CHART_REPO_PATH"
              fi

        - name: üß™ TESTS - Run Preflight TestSuite
          if: ${{ inputs.enable-helm-chart-tests == 'true' }}
          shell: bash
          run: |
              set -euo pipefail

              task -d "${CI_TASKS_BASE_DIR}/chart-full-setup" test.preflight

        - name: üß™ TESTS - Run Core TestSuite
          if: ${{ inputs.enable-helm-chart-tests == 'true' }}
          shell: bash
          run: |
              set -euo pipefail

              task -d "${CI_TASKS_BASE_DIR}/chart-full-setup" test.core

        - name: üß™ TESTS - Run zeebe client tests
          if: ${{ inputs.enable-zeebe-client-tests == 'true' }}
          shell: bash
          env:
              CAMUNDA_DOMAIN: ${{ inputs.camunda-domain }}
              CLUSTER_2_NAME: ${{ inputs.cluster-2-name || '' }}
              CAMUNDA_NAMESPACE_2: ${{ inputs.camunda-namespace-2 || '' }}
              CAMUNDA_NAMESPACE_1: ${{ inputs.camunda-namespace-1 || '' }}
              CAMUNDA_RELEASE_NAME: ${{ inputs.test-release-name || '' }}
          run: |
              set -euo pipefail

              reference_file="${{ inputs.zeebe-topology-golden-file }}"
              topology_check_script="${{ inputs.zeebe-topology-check-script }}"
              zeebe_authenticated="${{ inputs.zeebe-authenticated }}"

              echo "Using golden reference file to compare against: $reference_file"
              echo "Using topology check script: $topology_check_script"

              if [[ "$zeebe_authenticated" == "true" ]]; then
                echo "Using authenticated Zeebe client credentials..."
                export ZEEBE_CLIENT_ID="${{ inputs.test-client-id }}"
                export ZEEBE_CLIENT_SECRET="${{ inputs.test-client-secret }}"
              fi

              # function to help with port-forwarding in the background
              start_port_forward() {
                  local service=$1
                  local ports=$2
                  kubectl port-forward service/$service $ports -n $TEST_NAMESPACE >/dev/null 2>&1 &
                  local pid=$!
                  PORT_FORWARD_PIDS+=($pid)
                  echo "Port-forwarding for $service on ports $ports started."
              }

              cleanup() {
                for pid in "${PORT_FORWARD_PIDS[@]}"; do
                  echo "üõë Stopping port-forward (PID: $pid)..."
                  kill "$pid" 2>/dev/null || echo "‚ö†Ô∏è Failed to kill PID $pid"
                done
              }

              trap cleanup EXIT

              PORT_FORWARD_PIDS=()

              # Dual-Region includes the portforwarding itself, therefore skipping it here
              if [[ -z "$CAMUNDA_DOMAIN" && -z "$CLUSTER_2_NAME" ]]; then
                # Without domain:
                source ./generic/kubernetes/single-region/procedure/export-verify-zeebe-local.sh

                # Parse Keycloak service name and port from KEYCLOAK_TARGET
                if [[ "$KEYCLOAK_TARGET" == *":"* ]]; then
                  KEYCLOAK_SERVICE_NAME="${KEYCLOAK_TARGET%:*}"
                  KEYCLOAK_SERVICE_PORT="${KEYCLOAK_TARGET#*:}"
                else
                  KEYCLOAK_SERVICE_NAME="$KEYCLOAK_TARGET"
                  KEYCLOAK_SERVICE_PORT="8080"
                fi

                echo "Using Keycloak service: $KEYCLOAK_SERVICE_NAME:$KEYCLOAK_SERVICE_PORT"

                start_port_forward "${CAMUNDA_RELEASE_NAME}-zeebe-gateway" 8080:8080

                # Setup Keycloak port-forwarding with dynamic port
                start_port_forward "$KEYCLOAK_SERVICE_NAME" "18080:$KEYCLOAK_SERVICE_PORT"

                echo "Waiting for port-forwarding to be established..." && sleep 10
              else
                # With domain:
                source ./generic/kubernetes/single-region/procedure/export-verify-zeebe-domain.sh
              fi

              # Execute the script and capture the output in a variable
              eval "$topology_check_script"
              check_zeebe_topology_output=$(<zeebe-topology.json)

              # Checks
              error_found=false
              check_zeebe_topology_all_healthy=$(echo "$check_zeebe_topology_output" | jq '[.brokers[].partitions[].health == "healthy"] | all')
              check_zeebe_topology_cluster_size=$(echo "$check_zeebe_topology_output" | jq '.clusterSize')
              check_zeebe_topology_partitions_count=$(echo "$check_zeebe_topology_output" | jq '.partitionsCount')

              golden_zeebe_topology_cluster_size=$(jq '.clusterSize' < "$reference_file")
              golden_zeebe_topology_partitions_count=$(jq '.partitionsCount' < "$reference_file")

              if [ "$check_zeebe_topology_all_healthy" = "true" ]; then
                echo "‚úÖ All partitions are healthy."
              else
                echo "‚ùå Not all partitions are healthy"
                error_found=true
              fi

              if [ "$check_zeebe_topology_cluster_size" -eq $golden_zeebe_topology_cluster_size ]; then
                echo "‚úÖ Cluster size is $check_zeebe_topology_cluster_size."
              else
                echo "‚ùå Cluster size is not $golden_zeebe_topology_cluster_size."
                error_found=true
              fi

              if [ "$check_zeebe_topology_partitions_count" -eq $golden_zeebe_topology_partitions_count ]; then
                echo "‚úÖ Partitions count is $check_zeebe_topology_partitions_count."
              else
                echo "‚ùå Partitions count is not $golden_zeebe_topology_partitions_count."
                error_found=true
              fi

              echo "Comparing golden file of the zeebe topology output..."

              # Save the output to a temporary file
              temp_output=$(mktemp)
              echo "$check_zeebe_topology_output" > "$temp_output"

              # Replace patch version
              yq e '.brokers[].version |= sub("[.].*$", ".z") | .gatewayVersion |= sub("[.].*$", ".z")' -i "$temp_output"
              yq e '.brokers[].version |= sub("[.].*$", ".z") | .gatewayVersion |= sub("[.].*$", ".z")' -i "$reference_file"

              # Replace clusterId with fixed value
              yq e '.clusterId = "zzzzzz-xxxxx-yyyy-dddd-cccc"' -i "$temp_output"
              yq e '.clusterId = "zzzzzz-xxxxx-yyyy-dddd-cccc"' -i "$reference_file"

              # Replace namespace names with cluster names if env vars are set
              if [[ -n "${CLUSTER_2_NAME:-}" && -n "${CAMUNDA_NAMESPACE_2:-}" && -n "${CAMUNDA_NAMESPACE_1:-}" ]]; then
                echo "Replacing namespace values in golden file..."
                sed -e "s/cluster-region-2/$CLUSTER_2_NAME/g" \
                    -e "s/camunda-cluster-region-2\.svc/$CAMUNDA_NAMESPACE_2\.svc/g" \
                    -e "s/camunda-cluster-region-1\.svc/$CAMUNDA_NAMESPACE_1\.svc/g" \
                    -i "$reference_file"
              fi

              echo "Replacing release name value in golden file..."
              sed -e "s/camunda-zeebe/${CAMUNDA_RELEASE_NAME}-zeebe/g" -i "$reference_file"

              # Order each file also remove not predictable fields
              yq e '.brokers |= sort_by(.host) | .brokers[] |= (.partitions |= sort_by(.partitionId) | .partitions[].role = "NOT_PREDICTABLE")' -i "$temp_output"
              yq e '.brokers |= sort_by(.host) | .brokers[] |= (.partitions |= sort_by(.partitionId) | .partitions[].role = "NOT_PREDICTABLE")' -i "$reference_file"

              # Compare the two files using diff (in compacted JSON format)
              diff_output=$(delta <(jq -S . "$temp_output") <(jq -S . "$reference_file") || true)

              if [[ -n "$diff_output" ]]; then
                # If differences are found, print the error and the diff
                echo "‚ùå Error: The golden files of zeebe topology files do not match."
                echo "Differences found:"
                echo "$diff_output"

                # Display the new generated version
                echo "New version:"
                cat "$temp_output"

                error_found=true
              fi

              if [ "$error_found" = true ]; then
                echo "‚ùå Some tests failed."
                exit 1
              fi
              echo "‚úÖ The cluster meets all the expected criteria."

        - name: üß™ C8-SM-CHECKS - Run Deployment Check
          if: ${{ inputs.enable-c8sm-deployment-check == 'true' }}
          shell: bash
          env:
              NAMESPACE: ${{ inputs.test-namespace }}
              HELM_DEPLOYMENT_NAME: ${{ inputs.test-release-name }}
          run: |
              set -euo pipefail

              echo "üîç Running deployment check..."

              # Determine required containers based on what's enabled and Camunda version
              # For Camunda 8.8+, zeebe components are unified under 'orchestration'
              CAMUNDA_MAJOR_VERSION=$(echo "${{ inputs.camunda-version }}" | cut -d. -f1)
              CAMUNDA_MINOR_VERSION=$(echo "${{ inputs.camunda-version }}" | cut -d. -f2)

              # Camunda 8.8+ uses 'zeebe' instead of 'zeebe,zeebe-gateway'
              REQUIRED_CONTAINERS="connector,optimize,zeebe"

              if [[ "${{ inputs.webmodeler-enabled }}" == "true" ]]; then
                REQUIRED_CONTAINERS="${REQUIRED_CONTAINERS},web-modeler"
              fi

              if [[ "${{ inputs.console-enabled }}" == "true" ]]; then
                REQUIRED_CONTAINERS="${REQUIRED_CONTAINERS},console"
              fi

              echo "Required containers for Camunda ${{ inputs.camunda-version }}: $REQUIRED_CONTAINERS"

              C8_SM_CHECKS_PATH="${{ inputs.tests-c8-sm-checks-repo-path }}"
              chmod +x "$C8_SM_CHECKS_PATH/checks/kube/deployment.sh"
              "$C8_SM_CHECKS_PATH/checks/kube/deployment.sh" \
                -n "$NAMESPACE" \
                -d "$HELM_DEPLOYMENT_NAME" \
                -c "$REQUIRED_CONTAINERS"

        - name: üß™ C8-SM-CHECKS - Run Kubernetes Connectivity Check
          if: ${{ inputs.enable-c8sm-connectivity-check == 'true' }}
          shell: bash
          env:
              NAMESPACE: ${{ inputs.test-namespace }}
              CAMUNDA_DOMAIN: ${{ inputs.camunda-domain }}
          run: |
              set -euo pipefail

              echo "üîç Running Kubernetes connectivity check..."

              C8_SM_CHECKS_PATH="${{ inputs.tests-c8-sm-checks-repo-path }}"
              chmod +x "$C8_SM_CHECKS_PATH/checks/kube/connectivity.sh"

              # Skip ingress checks if no domain is configured
              if [[ -z "$CAMUNDA_DOMAIN" ]] || [[ "${{ inputs.skip-c8sm-connectivity-ingress-class-check }}" == "true" ]]; then
                echo "‚ÑπÔ∏è No domain configured, skipping ingress checks"
                "$C8_SM_CHECKS_PATH/checks/kube/connectivity.sh" -n "$NAMESPACE" -i
              else
                "$C8_SM_CHECKS_PATH/checks/kube/connectivity.sh" -n "$NAMESPACE"
              fi

        - name: üß™ C8-SM-CHECKS - Run AWS IRSA Check
          if: ${{ inputs.enable-c8sm-irsa-check == 'true' }}
          shell: bash
          env:
              NAMESPACE: ${{ inputs.test-namespace }}
              ELASTICSEARCH_ENABLED: ${{ inputs.elasticsearch-enabled }}
          run: |
              set -euo pipefail

              echo "üîç Running AWS IRSA check..."

              C8_SM_CHECKS_PATH="${{ inputs.tests-c8-sm-checks-repo-path }}"
              chmod +x "$C8_SM_CHECKS_PATH/checks/kube/aws-irsa.sh"

              # Exclude components based on configuration
              if [[ "$ELASTICSEARCH_ENABLED" == "true" ]]; then
                # If Elasticsearch is enabled, IRSA won't work with OpenSearch
                echo "‚ö†Ô∏è Elasticsearch is enabled, skipping IRSA checks"
                exit 0
              fi

              # Build component lists based on Camunda version
              CAMUNDA_MAJOR_VERSION=$(echo "${{ inputs.camunda-version }}" | cut -d. -f1)
              CAMUNDA_MINOR_VERSION=$(echo "${{ inputs.camunda-version }}" | cut -d. -f2)

              # Camunda 8.8+ uses 'orchestration' and 'optimize' for OpenSearch
              OS_COMPONENTS="orchestration,optimize"

              PG_COMPONENTS="identityKeycloak,identity"

              if [[ "${{ inputs.webmodeler-enabled }}" == "true" ]]; then
                PG_COMPONENTS="${PG_COMPONENTS},webModeler"
              fi

              echo "OpenSearch components: $OS_COMPONENTS"
              echo "PostgreSQL components: $PG_COMPONENTS"

              "$C8_SM_CHECKS_PATH/checks/kube/aws-irsa.sh" \
                -n "$NAMESPACE" \
                -p "$PG_COMPONENTS" \
                -l "$OS_COMPONENTS"

        - name: üîß Configure /etc/hosts for local domain mode
          if: ${{ inputs.local-domain-mode == 'true' && inputs.camunda-domain != '' }}
          shell: bash
          env:
              CAMUNDA_DOMAIN: ${{ inputs.camunda-domain }}
              CAMUNDA_DOMAIN_GRPC: ${{ inputs.camunda-domain-grpc }}
              LOCAL_DOMAIN_IP: ${{ inputs.local-domain-ip }}
          run: |
              set -euo pipefail

              echo "üîß Configuring /etc/hosts for local domain mode..."
              echo "   Using IP: $LOCAL_DOMAIN_IP"

              # Add main Camunda domain
              if [[ -n "$CAMUNDA_DOMAIN" ]]; then
                echo "Adding hosts entry: $LOCAL_DOMAIN_IP $CAMUNDA_DOMAIN"
                echo "$LOCAL_DOMAIN_IP $CAMUNDA_DOMAIN" | sudo tee -a /etc/hosts
              fi

              # Add gRPC domain if different from main domain
              # Extract hostname from port if present (e.g., zeebe-camunda.example.com:443 -> zeebe-camunda.example.com)
              if [[ -n "$CAMUNDA_DOMAIN_GRPC" ]]; then
                GRPC_HOST="${CAMUNDA_DOMAIN_GRPC%%:*}"
                if [[ "$GRPC_HOST" != "$CAMUNDA_DOMAIN" ]]; then
                  echo "Adding hosts entry: $LOCAL_DOMAIN_IP $GRPC_HOST"
                  echo "$LOCAL_DOMAIN_IP $GRPC_HOST" | sudo tee -a /etc/hosts
                fi
              fi

              echo ""
              echo "‚úÖ /etc/hosts configured for local domain mode:"
              grep -E "($CAMUNDA_DOMAIN|${CAMUNDA_DOMAIN_GRPC%%:*})" /etc/hosts || true

        - name: üß™ C8-SM-CHECKS - Run Zeebe Token Generation Check
          if: ${{ inputs.enable-c8sm-zeebe-token-check == 'true' && inputs.zeebe-authenticated == 'true' && inputs.camunda-domain != '' }}
          shell: bash
          env:
              ZEEBE_AUTHORIZATION_SERVER_URL: ${{ format('https://{0}/auth/realms/camunda-platform/protocol/openid-connect/token', inputs.camunda-domain)
                  }}
              ZEEBE_CLIENT_ID: ${{ inputs.test-client-id }}
              ZEEBE_CLIENT_SECRET: ${{ inputs.test-client-secret }}
              ZEEBE_TOKEN_AUDIENCE: orchestration-api
          run: |
              set -euo pipefail

              echo "üîç Running Zeebe token generation check..."

              C8_SM_CHECKS_PATH="${{ inputs.tests-c8-sm-checks-repo-path }}"
              chmod +x "$C8_SM_CHECKS_PATH/checks/zeebe/token.sh"

              "$C8_SM_CHECKS_PATH/checks/zeebe/token.sh" \
                -a "$ZEEBE_AUTHORIZATION_SERVER_URL" \
                -i "$ZEEBE_CLIENT_ID" \
                -s "$ZEEBE_CLIENT_SECRET" \
                -u "$ZEEBE_TOKEN_AUDIENCE"

        - name: üß™ C8-SM-CHECKS - Run Zeebe Connectivity Check
          if: ${{ inputs.enable-c8sm-zeebe-connectivity-check == 'true' && inputs.enable-zeebe-client-tests == 'true' && inputs.camunda-domain != '' }}
          shell: bash
          env:
              ZEEBE_ADDRESS: ${{ inputs.camunda-domain-grpc || format('{0}:443', inputs.camunda-domain) }}
              ZEEBE_AUTHORIZATION_SERVER_URL: ${{ format('https://{0}/auth/realms/camunda-platform/protocol/openid-connect/token', inputs.camunda-domain)
                  }}
              ZEEBE_CLIENT_ID: ${{ inputs.test-client-id }}
              ZEEBE_CLIENT_SECRET: ${{ inputs.test-client-secret }}
              ZEEBE_TOKEN_AUDIENCE: orchestration-api
              ZEEBE_DEFAULT_VERSION: ${{ inputs.camunda-version }}
          run: |
              set -euo pipefail

              echo "üîç Running Zeebe connectivity check..."

              C8_SM_CHECKS_PATH="${{ inputs.tests-c8-sm-checks-repo-path }}"
              chmod +x "$C8_SM_CHECKS_PATH/checks/zeebe/connectivity.sh"

              "$C8_SM_CHECKS_PATH/checks/zeebe/connectivity.sh" \
                -H "$ZEEBE_ADDRESS" \
                -p "$ZEEBE_DEFAULT_VERSION" \
                -a "$ZEEBE_AUTHORIZATION_SERVER_URL" \
                -i "$ZEEBE_CLIENT_ID" \
                -s "$ZEEBE_CLIENT_SECRET" \
                -u "$ZEEBE_TOKEN_AUDIENCE" \
                -q grpc

        - name: ÔøΩÔ∏è Install asdf tools with cache
          uses: camunda/infraex-common-config/./.github/actions/asdf-install-tooling@193a21e1e56c9a65517a822224ac3b4ffa4d6ae4 # 1.5.9

        - name: üé≠ HELM PLAYWRIGHT - Setup Node.js
          if: ${{ inputs.enable-helm-playwright-tests == 'true' && inputs.camunda-domain != '' }}
          uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
          with:
              node-version: '24'

        - name: üé≠ HELM PLAYWRIGHT - Verify prerequisites
          id: playwright-prereqs
          if: ${{ inputs.enable-helm-playwright-tests == 'true' && inputs.camunda-domain != '' }}
          shell: bash
          env:
              CAMUNDA_VERSION: ${{ inputs.camunda-version }}
              TESTS_CAMUNDA_HELM_CHART_REPO_PATH: ${{ inputs.tests-camunda-helm-chart-repo-path }}
          run: |
              set -euo pipefail

              echo "üîç Verifying Helm Playwright test prerequisites..."

              TEST_SUITE_PATH="${TESTS_CAMUNDA_HELM_CHART_REPO_PATH}/charts/camunda-platform-${CAMUNDA_VERSION}/test/e2e"

              # Export paths to GITHUB_ENV for subsequent steps
              echo "HELM_PLAYWRIGHT_TEST_SUITE_PATH=$TEST_SUITE_PATH" >> "$GITHUB_ENV"
              echo "test-suite-path=$TEST_SUITE_PATH" >> "$GITHUB_OUTPUT"

              # Verify test suite exists
              if [[ ! -d "$TEST_SUITE_PATH" ]]; then
                echo "‚ö†Ô∏è Test suite path not found: $TEST_SUITE_PATH"
                echo "   Helm Playwright tests will be skipped."
                echo "test-suite-exists=false" >> "$GITHUB_OUTPUT"
                exit 0
              fi

              echo "test-suite-exists=true" >> "$GITHUB_OUTPUT"

              # Verify required tools are available
              echo "Checking required tools..."
              for tool in node npm kubectl; do
                if ! command -v "$tool" &> /dev/null; then
                  echo "‚ùå Required tool not found: $tool"
                  exit 1
                fi
                echo "  ‚úÖ $tool: $(command -v $tool)"
              done

              echo "‚úÖ All prerequisites verified"
              echo "   Test suite path: $TEST_SUITE_PATH"

        - name: üé≠ HELM PLAYWRIGHT - Install Node.js dependencies
          if: ${{ inputs.enable-helm-playwright-tests == 'true' && inputs.camunda-domain != '' }}
          shell: bash
          working-directory: ${{ env.HELM_PLAYWRIGHT_TEST_SUITE_PATH }}
          run: |
              set -euo pipefail

              echo "üì¶ Installing Node.js dependencies for Playwright tests..."
              echo "::group::Installing dependencies"
              rm -rf node_modules package-lock.json
              npm install
              echo "::endgroup::"
              echo "::group::Verifying e2e-test-suite"
              cat package-lock.json | grep e2e-test-suite
              echo "::endgroup::"

              echo "üé≠ Installing Playwright browsers..."
              echo "::group::Installing Playwright browsers"
              npx playwright install --with-deps chromium
              echo "::endgroup::"

        - name: üé≠ HELM PLAYWRIGHT - Setup environment file
          id: playwright-env
          if: ${{ inputs.enable-helm-playwright-tests == 'true' && inputs.camunda-domain != '' }}
          shell: bash
          env:
              CAMUNDA_VERSION: ${{ inputs.camunda-version }}
              CAMUNDA_DOMAIN: ${{ inputs.camunda-domain }}
              TEST_NAMESPACE: ${{ inputs.test-namespace }}
              TEST_AUTH_TYPE: ${{ inputs.helm-playwright-test-auth-type }}
              TEST_CLIENT_ID: ${{ inputs.test-client-id }}
              ORCHESTRATION_CONTEXT_PATH: ${{ inputs.helm-playwright-orchestration-context-path }}
              MANAGEMENT_IDENTITY_CONTEXT_PATH: ${{ inputs.helm-playwright-identity-context-path }}
              FIRSTUSER_USERNAME: ${{ inputs.helm-playwright-firstuser-username }}
              FIRSTUSER_SECRET_NAME: ${{ inputs.helm-playwright-firstuser-secret-name }}
              FIRSTUSER_SECRET_KEY: ${{ inputs.helm-playwright-firstuser-secret-key }}
              KEYCLOAK_SECRET_NAME: ${{ inputs.helm-playwright-keycloak-secret-name }}
              KEYCLOAK_SECRET_KEY: ${{ inputs.helm-playwright-keycloak-secret-key }}
              KEYCLOAK_USERNAME: ${{ inputs.helm-playwright-keycloak-username }}
          run: |
              set -euo pipefail

              ENV_FILE="${HELM_PLAYWRIGHT_TEST_SUITE_PATH}/.env"

              echo "üìù Setting up Playwright environment file..."

              # Write .env file (no leading whitespace ‚Äî dotenv requires flush-left lines)
              cat > "$ENV_FILE" <<ENVEOF
              OAUTH_URL=https://${CAMUNDA_DOMAIN}/auth/realms/camunda-platform/protocol/openid-connect/token
              ORCHESTRATION_CONTEXT_PATH=${ORCHESTRATION_CONTEXT_PATH}
              MANAGEMENT_IDENTITY_CONTEXT_PATH=${MANAGEMENT_IDENTITY_CONTEXT_PATH}
              TEST_AUTH_TYPE=${TEST_AUTH_TYPE}
              TEST_CLIENT_ID=${TEST_CLIENT_ID}
              SKIP_TEST_INGRESS=false
              SKIP_TEST_WEBMODELER=false
              TASKLIST_VERSION=v2
              PLAYWRIGHT_BASE_URL=https://${CAMUNDA_DOMAIN}
              KEYCLOAK_URL=https://${CAMUNDA_DOMAIN}
              MINOR_VERSION=SM-${CAMUNDA_VERSION}
              CLUSTER_VERSION=
              DISTRO_QA_E2E_TESTS_IDENTITY_FIRSTUSER_USERNAME=${FIRSTUSER_USERNAME}
              DISTRO_QA_E2E_TESTS_KEYCLOAK_USERNAME=${KEYCLOAK_USERNAME}
              CI=true
              VERBOSE=true
              ENVEOF

              # Remove leading whitespace from every line (heredoc inside YAML inherits indentation)
              sed -i 's/^[[:space:]]*//' "$ENV_FILE"

              # First user credentials
              firstuser_password=$(kubectl -n "$TEST_NAMESPACE" \
                get secret "$FIRSTUSER_SECRET_NAME" \
                -o jsonpath="{.data.${FIRSTUSER_SECRET_KEY}}" 2>/dev/null | base64 -d 2>/dev/null || true)

              if [[ -n "$firstuser_password" ]]; then
                echo "::add-mask::$firstuser_password"
              else
                echo "‚ö†Ô∏è Could not extract first user password from secret $FIRSTUSER_SECRET_NAME/$FIRSTUSER_SECRET_KEY"
              fi
              echo "DISTRO_QA_E2E_TESTS_IDENTITY_FIRSTUSER_PASSWORD=${firstuser_password}" >> "$ENV_FILE"

              # Keycloak admin password
              keycloak_password=$(kubectl -n "$TEST_NAMESPACE" \
                get secret "$KEYCLOAK_SECRET_NAME" \
                -o jsonpath="{.data.${KEYCLOAK_SECRET_KEY}}" 2>/dev/null | base64 -d 2>/dev/null || true)

              if [[ -n "$keycloak_password" ]]; then
                echo "::add-mask::$keycloak_password"
              else
                echo "‚ö†Ô∏è Could not extract keycloak password from secret $KEYCLOAK_SECRET_NAME/$KEYCLOAK_SECRET_KEY"
              fi
              echo "DISTRO_QA_E2E_TESTS_KEYCLOAK_PASSWORD=${keycloak_password}" >> "$ENV_FILE"

              echo "‚úÖ Environment file created at $ENV_FILE"
              echo "üìã .env contents (secrets masked):"
              grep -v 'PASSWORD' "$ENV_FILE" || true

        - name: üé≠ HELM PLAYWRIGHT - Run e2e tests
          id: helm-playwright-tests
          if: ${{ inputs.enable-helm-playwright-tests == 'true' && inputs.camunda-domain != '' }}
          shell: bash
          working-directory: ${{ env.HELM_PLAYWRIGHT_TEST_SUITE_PATH }}
          env:
              TEST_AUTH_TYPE: ${{ inputs.helm-playwright-test-auth-type }}
              TEST_PROJECT: ${{ inputs.helm-playwright-test-project }}
              TEST_EXCLUDE: ${{ inputs.helm-playwright-test-exclude }}
          run: |
              set -euo pipefail

              echo "üé≠ Running Helm Playwright integration tests..."
              echo "   Project: $TEST_PROJECT"
              echo "   Auth type: $TEST_AUTH_TYPE"
              echo "   Exclude: ${TEST_EXCLUDE:-none}"

              # Patch Playwright config: ignore HTTPS errors, disable retries, set 3min timeout
              node -e "
                const fs = require('fs');
                let config = fs.readFileSync('playwright.config.ts', 'utf8');
                config = config.replace(/use:\s*{/, 'use: {\n    ignoreHTTPSErrors: true,');
                config = config.replace(/retries:\s*\d+/, 'retries: 0');
                fs.writeFileSync('playwright.config.ts', config);
              "

              # Build playwright arguments
              PLAYWRIGHT_ARGS="--project=$TEST_PROJECT --reporter=html,list"

              if [[ -n "$TEST_EXCLUDE" ]]; then
                PLAYWRIGHT_ARGS="$PLAYWRIGHT_ARGS --grep-invert=\"$TEST_EXCLUDE\""
              fi

              # Run all tests with the specified auth type
              if npx playwright test $PLAYWRIGHT_ARGS; then
                echo "result=success" >> "$GITHUB_OUTPUT"
                echo "‚úÖ All Playwright tests passed!"
              else
                echo "result=failure" >> "$GITHUB_OUTPUT"
                echo "‚ùå Some Playwright tests failed"
                exit 1
              fi

        - name: üé≠ HELM PLAYWRIGHT - Upload test artifacts
          if: ${{ inputs.enable-helm-playwright-tests == 'true' && inputs.helm-playwright-upload-artifacts == 'true' || failure() }}
          uses: actions/upload-artifact@834a144ee995460fba8ed112a2fc961b36a5ec5a # v4
          with:
              name: helm-playwright-report-${{ github.run_id }}-${{ github.run_attempt }}
              path: |
                  ${{ steps.playwright-prereqs.outputs.test-suite-path }}/playwright-report
                  ${{ steps.playwright-prereqs.outputs.test-suite-path }}/test-results
              retention-days: ${{ inputs.helm-playwright-artifact-retention-days }}
