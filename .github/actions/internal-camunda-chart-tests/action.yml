---
name: Camunda Chart Tests

description: >
    Run the Camunda Helm chart tests.
    Already requires the Helm chart to be deployed and cluster access granted.

    This action integrates multiple testing layers:
    1. Helm chart integration tests (from camunda-platform-helm)
    2. C8 Self-Managed checks (from c8-sm-checks repository):
       - Deployment verification (checks pods and containers status)
       - Kubernetes connectivity checks (services and ingress resolution)
       - AWS IRSA configuration checks (for EKS clusters with IRSA)
       - Zeebe token generation and connectivity checks

    All C8 SM checks can be individually enabled/disabled via inputs.

inputs:
    tests-camunda-helm-chart-repo-ref:
        description: The branch, tag or commit to checkout
        default: main
    tests-camunda-helm-chart-repo-path:
        description: Path to the Helm chart repository
        default: ./.camunda_helm_repo
    tests-c8-sm-checks-repo-ref:
        description: The branch, tag or commit to checkout for c8-sm-checks
        default: main
    tests-c8-sm-checks-repo-path:
        description: Path to clone the c8-sm-checks repository
        default: ./.c8-sm-checks
    secrets:
        description: JSON wrapped secrets for easier secret passing
        required: true
    camunda-version:
        description: The version of the Camunda to test
        required: true
    camunda-domain:
        description: The domain to use for the tests
        default: ''
    camunda-domain-grpc:
        description: The domain to use for the gRPC tests
        default: ''
    webmodeler-enabled:
        description: Whether the Webmodeler is enabled in the chart
        default: 'false'
    console-enabled:
        description: Whether the Console is enabled in the chart
        default: 'false'
    elasticsearch-enabled:
        description: Whether the Elasticsearch is enabled in the chart
        default: 'true'
    test-namespace:
        description: The namespace to use for the helm tests
        default: camunda
    test-release-name:
        description: The helm release name to used for by the helm tests
        default: camunda
    test-cluster-type:
        description: The type of the cluster to use for the tests
        default: kubernetes
    zeebe-topology-golden-file:
        description: The golden file to compare the Zeebe topology output against.
        default: ./generic/kubernetes/single-region/procedure/check-zeebe-cluster-topology-output.json
    zeebe-topology-check-script:
        description: The script called to the current Zeebe topology.
        default: ./generic/kubernetes/single-region/procedure/check-zeebe-cluster-topology.sh
    zeebe-authenticated:
        description: Use the authentication layer to interact with zeebe
        default: 'true'
    enable-helm-chart-tests:
        description: Whether the Helm Chart tests should be run
        default: 'true'
    enable-zeebe-client-tests:
        description: Whether the Zeebe Client tests should be run
        default: 'true'
    cluster-2-name:
        description: Optional cluster 2 name for sed replacement (dual-region only)
        required: false
    camunda-namespace-2:
        description: Optional namespace for region 2 (dual-region only)
        required: false
    camunda-namespace-1:
        description: Optional namespace for region 1 (dual-region only)
        required: false
    keycloak-service-name:
        description: Name of the Keycloak service with optional port (e.g. keycloak-service:8080)
        default: ''  # Will use ${CAMUNDA_RELEASE_NAME}-keycloak:8080 by default
    elasticsearch-service-name:
        description: Name of the Elasticsearch service with optional port (e.g. elasticsearch-es-http:9200)
        default: ''  # Will use ${CAMUNDA_RELEASE_NAME}-elasticsearch by default
    test-client-id:
        description: Client ID for Camunda authentication tests
        required: true
    test-client-secret:
        description: Client secret for Camunda authentication tests
        required: true
    enable-c8sm-deployment-check:
        description: Whether the C8 SM deployment check should be run
        default: 'true'
    enable-c8sm-connectivity-check:
        description: Whether the C8 SM Kubernetes connectivity check should be run
        default: 'true'
    skip-c8sm-connectivity-ingress-class-check:
        description: Whether to skip the ingress class check part of the C8 SM Kubernetes connectivity check
        default: 'false'
    enable-c8sm-irsa-check:
        description: Whether the C8 SM AWS IRSA check should be run (only applicable for EKS)
        default: 'false'
    enable-c8sm-zeebe-token-check:
        description: Whether the C8 SM Zeebe token generation check should be run
        default: 'true'
    enable-c8sm-zeebe-connectivity-check:
        description: Whether the C8 SM Zeebe connectivity check should be run
        default: 'true'
    local-domain-mode:
        description: >
            Enable local domain mode. When true, /etc/hosts entries will be added
            to resolve camunda.example.com and zeebe-camunda.example.com to 127.0.0.1.
            This is required for local Kind clusters with domain-based access where
            the runner needs to access the ingress via localhost.
        default: 'false'
    local-domain-ip:
        description: >
            The IP address to use for local domain resolution in /etc/hosts.
            Defaults to 127.0.0.1 for standard local development.
        default: 127.0.0.1

runs:
    using: composite
    steps:
        - name: Import Secrets
          id: secrets
          if: ${{ inputs.enable-helm-chart-tests == 'true' || inputs.zeebe-authenticated == 'true' }}
          uses: hashicorp/vault-action@4c06c5ccf5c0761b6029f56cfb1dcf5565918a3b # v3
          with:
              url: ${{ fromJSON(inputs.secrets).VAULT_ADDR }}
              method: approle
              roleId: ${{ fromJSON(inputs.secrets).VAULT_ROLE_ID }}
              secretId: ${{ fromJSON(inputs.secrets).VAULT_SECRET_ID }}
              exportEnv: false
              secrets: |
                  secret/data/products/infrastructure-experience/ci/common DOCKERHUB_USER;
                  secret/data/products/infrastructure-experience/ci/common DOCKERHUB_PASSWORD;

        - name: üßô‚Äç‚ôÇÔ∏è Clone camunda/camunda-platform-helm
          uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
          if: ${{ inputs.enable-helm-chart-tests == 'true' }}
          with:
              repository: camunda/camunda-platform-helm
              ref: ${{ inputs.tests-camunda-helm-chart-repo-ref }}
              path: ${{ inputs.tests-camunda-helm-chart-repo-path }}
              fetch-depth: 0

        - name: üßô‚Äç‚ôÇÔ∏è Clone camunda/c8-sm-checks
          uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
          with:
              repository: camunda/c8-sm-checks
              ref: ${{ inputs.tests-c8-sm-checks-repo-ref }}
              path: ${{ inputs.tests-c8-sm-checks-repo-path }}
              fetch-depth: 0

        - name: üìã Display C8-SM-CHECKS Configuration
          shell: bash
          run: |
              set -euo pipefail

              echo "======================================"
              echo "C8 Self-Managed Checks Configuration"
              echo "======================================"
              echo ""
              echo "Tests enabled:"
              echo "  - Deployment Check: ${{ inputs.enable-c8sm-deployment-check }}"
              echo "  - Kubernetes Connectivity Check: ${{ inputs.enable-c8sm-connectivity-check }}"
              echo "  - AWS IRSA Check: ${{ inputs.enable-c8sm-irsa-check }}"
              echo "  - Zeebe Token Generation Check: ${{ inputs.enable-c8sm-zeebe-token-check }}"
              echo "  - Zeebe Connectivity Check: ${{ inputs.enable-c8sm-zeebe-connectivity-check }}"
              echo ""
              echo "Configuration:"
              echo "  - Namespace: ${{ inputs.test-namespace }}"
              echo "  - Release Name: ${{ inputs.test-release-name }}"
              echo "  - Cluster Type: ${{ inputs.test-cluster-type }}"
              echo "  - Domain: ${{ inputs.camunda-domain || '(not configured)' }}"
              echo "  - WebModeler Enabled: ${{ inputs.webmodeler-enabled }}"
              echo "  - Console Enabled: ${{ inputs.console-enabled }}"
              echo "  - Elasticsearch Enabled: ${{ inputs.elasticsearch-enabled }}"
              echo ""
              echo "======================================"

        - name: üîß Configure service references
          shell: bash
          env:
              CAMUNDA_RELEASE_NAME: ${{ inputs.test-release-name }}
          run: |
              set -euo pipefail

              # Configure Keycloak service reference
              KEYCLOAK_SERVICE_INPUT="${{ inputs.keycloak-service-name }}"
              KEYCLOAK_TARGET="${KEYCLOAK_SERVICE_INPUT:-${CAMUNDA_RELEASE_NAME}-keycloak:8080}"

              # Configure Elasticsearch service reference
              ELASTICSEARCH_SERVICE_INPUT="${{ inputs.elasticsearch-service-name }}"
              ELASTICSEARCH_TARGET="${ELASTICSEARCH_SERVICE_INPUT:-${CAMUNDA_RELEASE_NAME}-elasticsearch:9200}"

              # Export service configurations for subsequent steps
              echo "KEYCLOAK_TARGET=$KEYCLOAK_TARGET" | tee -a "$GITHUB_ENV"
              echo "ELASTICSEARCH_TARGET=$ELASTICSEARCH_TARGET" | tee -a "$GITHUB_ENV"

        - name: üß™ TESTS - Set variables
          if: ${{ inputs.enable-helm-chart-tests == 'true' }}
          shell: bash
          env:
              CAMUNDA_VERSION: ${{ inputs.camunda-version }}
              CAMUNDA_DOMAIN: ${{ inputs.camunda-domain }}
              CAMUNDA_DOMAIN_GRPC: ${{ inputs.camunda-domain-grpc }}
              WEBMODELER_ENABLED: ${{ inputs.webmodeler-enabled }}
              CONSOLE_ENABLED: ${{ inputs.console-enabled }}
              ELASTICSEARCH_ENABLED: ${{ inputs.elasticsearch-enabled }}
          run: |
              set -euo pipefail

              # export test variables to be used in other steps
              echo "TEST_NAMESPACE=${{ inputs.test-namespace }}" | tee -a "$GITHUB_ENV"
              echo "TEST_CHART_NAME=${{ inputs.test-release-name }}" | tee -a "$GITHUB_ENV"
              echo "TEST_CLUSTER_TYPE=$TEST_CLUSTER_TYPE" | tee -a "$GITHUB_ENV"
              export TESTS_CAMUNDA_HELM_CHART_REPO_PATH="${{ inputs.tests-camunda-helm-chart-repo-path }}"
              echo "TESTS_CAMUNDA_HELM_CHART_REPO_PATH=$TESTS_CAMUNDA_HELM_CHART_REPO_PATH" | tee -a "$GITHUB_ENV"

              export TEST_CHART_DIR_STATIC="$TESTS_CAMUNDA_HELM_CHART_REPO_PATH/charts/camunda-platform-$CAMUNDA_VERSION"
              echo "TEST_CHART_DIR_STATIC=$TEST_CHART_DIR_STATIC" | tee -a "$GITHUB_ENV"

              TEST_INGRESS_HOST="$CAMUNDA_DOMAIN"
              echo "TEST_INGRESS_HOST=$TEST_INGRESS_HOST" | tee -a "$GITHUB_ENV"

              # shellcheck disable=SC2002
              TEST_CHART_VERSION=$(cat "$TEST_CHART_DIR_STATIC/Chart.yaml" | yq '.version')
              echo "TEST_CHART_VERSION=$TEST_CHART_VERSION" | tee -a "$GITHUB_ENV"

              # setup docker registry secret for tests
              echo "TEST_CREATE_DOCKER_LOGIN_SECRET=true" | tee -a "$GITHUB_ENV"
              echo "TEST_DOCKER_USERNAME_CAMUNDA_CLOUD=${{ steps.secrets.outputs.DOCKERHUB_USER }}" | tee -a "$GITHUB_ENV"
              echo "TEST_DOCKER_PASSWORD_CAMUNDA_CLOUD=${{ steps.secrets.outputs.DOCKERHUB_PASSWORD }}" | tee -a "$GITHUB_ENV"

              CI_TASKS_BASE_DIR="$TESTS_CAMUNDA_HELM_CHART_REPO_PATH/test/integration/scenarios/"
              echo "CI_TASKS_BASE_DIR=$CI_TASKS_BASE_DIR" | tee -a "$GITHUB_ENV"
              export TEST_CHART_DIR="../../../../charts/camunda-platform-$CAMUNDA_VERSION"
              echo "TEST_CHART_DIR=$TEST_CHART_DIR" | tee -a "$GITHUB_ENV"
              export TEST_VALUES_BASE_DIR="$TESTS_CAMUNDA_HELM_CHART_REPO_PATH/test/integration/scenarios"
              echo "TEST_VALUES_BASE_DIR=$TEST_VALUES_BASE_DIR" | tee -a "$GITHUB_ENV"

              # replace integration with the camunda release name as part of adaptation required to run the tests in our environment
              if [[ "${{ inputs.enable-helm-chart-tests }}" == "true" ]]; then
                find "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/" -type f -print0 | xargs -0 sed -i "s/integration/$CAMUNDA_RELEASE_NAME/g"

                # Use pre-configured service references from environment
                echo "Updating service references:"
                echo "  Keycloak: http://$KEYCLOAK_TARGET"
                echo "  Elasticsearch: http://$ELASTICSEARCH_TARGET"

                # Update variables-default.yaml (used for no-domain scenarios)
                yq eval ".preflightVars.baseURLs.keycloak = \"http://${KEYCLOAK_TARGET}\"" -i \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"
                yq eval ".preflightVars.baseURLs.elasticsearch = \"http://${ELASTICSEARCH_TARGET}\"" -i \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"
                yq eval ".coreVars.authURL = \"http://${KEYCLOAK_TARGET}/auth/realms/camunda-platform/protocol/openid-connect/token\"" -i \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"

                # Update variables-ingress-combined.yaml (used for domain/ingress scenarios)
                # For domain scenarios, keep the public HTTPS URLs, only update internal service references
                if [[ -f "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml" ]]; then
                  # Only update preflightVars (internal service checks) and elasticsearch
                  yq eval ".preflightVars.baseURLs.keycloak = \"http://${KEYCLOAK_TARGET}\"" -i \
                    "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"
                  yq eval ".preflightVars.baseURLs.elasticsearch = \"http://${ELASTICSEARCH_TARGET}\"" -i \
                    "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"
                  yq eval ".coreVars.baseURLs.elasticsearch = \"http://${ELASTICSEARCH_TARGET}\"" -i \
                    "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"
                  # DO NOT update coreVars.baseURLs.keycloak - it should use the public ingress URL (https://$DOMAIN/auth/)
                  echo "Note: Keycloak coreVars URL preserved for public ingress access"
                fi

                echo "‚úÖ Service references updated successfully"

                echo "Configure Venom tests"
                # (adapted from https://github.com/camunda/camunda-platform-helm/blob/test/integration/scenarios/chart-full-setup/Taskfile.yaml#L56)
                export VARIABLES_ENV_FILE="$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables.env"

                # False because we run OIDC
                echo "VENOM_VAR_SKIP_TEST_KEYCLOAK=false" >> "$VARIABLES_ENV_FILE"

                # Enable the ingress tests

                if [[ "$CAMUNDA_DOMAIN" != "" ]]; then
                  # shellcheck disable=SC2129
                  echo "VENOM_VAR_TEST_INGRESS_HOST=$TEST_INGRESS_HOST" >> "$VARIABLES_ENV_FILE"
                  echo "VENOM_EXTRA_ARGS=--var-from-file=./vars/variables-ingress-combined.yaml" >> "$VARIABLES_ENV_FILE"

                  # Setting is broken and results in always skipping ingress tests
                  # This removes the faulty setting but should only be done in domain context
                  echo "Skip test ingress is also broken, fixing it"
                  yq eval '(.testcases[].steps[].skip |= map(select(test("skiptestingress", "i") | not)))' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml"
                  yq eval 'del(.. | select(has("skip") and .skip | length == 0).skip)' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml"

                  if [[ "$CAMUNDA_DOMAIN_GRPC" != "" ]]; then
                    yq eval '.coreVars.baseURLs.orchestrationGRPC = env(CAMUNDA_DOMAIN_GRPC)' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-ingress-combined.yaml"
                  fi
                else
                  # Some variables are not working correctly, patching it with yq directly
                  echo "VENOM_VAR_SKIP_TEST_INGRESS=true" >> "$VARIABLES_ENV_FILE"

                  # fix wrong default orchestrationGRPC port
                  yq eval '.coreVars.baseURLs.orchestrationGRPC |= (select(tag == "!!str") | sub("^http://", "") | sub(":9600$", ":26500"))' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/variables-default.yaml"
                fi

                echo "VENOM_VAR_TEST_CLIENT_ID=${{ inputs.test-client-id }}" >> "$VARIABLES_ENV_FILE"
                echo "VENOM_VAR_TEST_CLIENT_SECRET=${{ inputs.test-client-secret }}" >> "$VARIABLES_ENV_FILE"

                ZEEBE_VERSION=$(yq '.zeebe.image.tag' "$TEST_CHART_DIR_STATIC/values.yaml")
                # shellcheck disable=SC2129
                echo "ZEEBE_VERSION=$ZEEBE_VERSION" >> "$VARIABLES_ENV_FILE"
                # In case the Zeebe version has not been released officially yet.
                echo "ZEEBE_VERSION_FALLBACK=8.5.6" >> "$VARIABLES_ENV_FILE"

                echo "Patch the test files..."

                # TODO: [BUG] remove the patchs when https://github.com/camunda/camunda-platform-helm/issues/3081 is fixed
                echo "Patch expression ShoudBeFalse"
                sed -i "s/ ShouldBeFalse/ ShouldEqual 'false'/g" \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml" \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-preflight.yaml"

                echo "Patch expression ShouldBeTrue"
                sed -i "s/ ShouldBeTrue/ ShouldEqual 'true'/g" \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml" \
                  "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-preflight.yaml"

                if [[ "$ELASTICSEARCH_ENABLED" != "true" ]]; then
                  echo "Disable Elasticsearch in the core tests as it's not enabled"

                  yq eval 'del(.. | select(has("component") and .component == "Elasticsearch"))' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-preflight.yaml"
                fi

                if [ "$WEBMODELER_ENABLED" != "true" ]; then
                  echo "Disable Webmodeler in the core tests as it's not enabled"

                  echo "VENOM_VAR_SKIP_TEST_WEBMODELER=false" >> "$VARIABLES_ENV_FILE"
                  yq eval 'del(.. | select(has("component") and .component == "WebModeler"))' \
                    -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/vars/files/testsuite-core.yaml"
                fi

                echo "Patch the identity secrets to allow venom to access to the platform"
                sed -i -e 's/integration-test-credentials/identity-secret-for-components/g' \
                        "$TEST_CHART_DIR_STATIC/test/integration/testsuites/core/patches/job.yaml"

                # remove venom var client secret as we define it in the file
                yq e 'del(.spec.template.spec.containers[].env[] | select(.name == "VENOM_VAR_TEST_CLIENT_SECRET"))' \
                  -i "$TEST_CHART_DIR_STATIC/test/integration/testsuites/core/patches/job.yaml"

                # we're overwriting the tool-versions of the Helm chart tests with our own
                echo "Ensure asdf tool is available in the test suite by using our global one"
                cp .tool-versions "$TESTS_CAMUNDA_HELM_CHART_REPO_PATH"
              fi

        - name: üß™ TESTS - Run Preflight TestSuite
          if: ${{ inputs.enable-helm-chart-tests == 'true' }}
          shell: bash
          run: |
              set -euo pipefail

              task -d "${CI_TASKS_BASE_DIR}/chart-full-setup" test.preflight

        - name: üß™ TESTS - Run Core TestSuite
          if: ${{ inputs.enable-helm-chart-tests == 'true' }}
          shell: bash
          run: |
              set -euo pipefail

              task -d "${CI_TASKS_BASE_DIR}/chart-full-setup" test.core

        - name: üß™ TESTS - Run zeebe client tests
          if: ${{ inputs.enable-zeebe-client-tests == 'true' }}
          shell: bash
          env:
              CAMUNDA_DOMAIN: ${{ inputs.camunda-domain }}
              CLUSTER_2_NAME: ${{ inputs.cluster-2-name || '' }}
              CAMUNDA_NAMESPACE_2: ${{ inputs.camunda-namespace-2 || '' }}
              CAMUNDA_NAMESPACE_1: ${{ inputs.camunda-namespace-1 || '' }}
              CAMUNDA_RELEASE_NAME: ${{ inputs.test-release-name || '' }}
          run: |
              set -euo pipefail

              reference_file="${{ inputs.zeebe-topology-golden-file }}"
              topology_check_script="${{ inputs.zeebe-topology-check-script }}"
              zeebe_authenticated="${{ inputs.zeebe-authenticated }}"

              echo "Using golden reference file to compare against: $reference_file"
              echo "Using topology check script: $topology_check_script"

              if [[ "$zeebe_authenticated" == "true" ]]; then
                echo "Using authenticated Zeebe client credentials..."
                export ZEEBE_CLIENT_ID="${{ inputs.test-client-id }}"
                export ZEEBE_CLIENT_SECRET="${{ inputs.test-client-secret }}"
              fi

              # function to help with port-forwarding in the background
              start_port_forward() {
                  local service=$1
                  local ports=$2
                  kubectl port-forward service/$service $ports -n $TEST_NAMESPACE >/dev/null 2>&1 &
                  local pid=$!
                  PORT_FORWARD_PIDS+=($pid)
                  echo "Port-forwarding for $service on ports $ports started."
              }

              cleanup() {
                for pid in "${PORT_FORWARD_PIDS[@]}"; do
                  echo "üõë Stopping port-forward (PID: $pid)..."
                  kill "$pid" 2>/dev/null || echo "‚ö†Ô∏è Failed to kill PID $pid"
                done
              }

              trap cleanup EXIT

              PORT_FORWARD_PIDS=()

              # Dual-Region includes the portforwarding itself, therefore skipping it here
              if [[ -z "$CAMUNDA_DOMAIN" && -z "$CLUSTER_2_NAME" ]]; then
                # Without domain:
                source ./generic/kubernetes/single-region/procedure/export-verify-zeebe-local.sh

                # Parse Keycloak service name and port from KEYCLOAK_TARGET
                if [[ "$KEYCLOAK_TARGET" == *":"* ]]; then
                  KEYCLOAK_SERVICE_NAME="${KEYCLOAK_TARGET%:*}"
                  KEYCLOAK_SERVICE_PORT="${KEYCLOAK_TARGET#*:}"
                else
                  KEYCLOAK_SERVICE_NAME="$KEYCLOAK_TARGET"
                  KEYCLOAK_SERVICE_PORT="8080"
                fi

                echo "Using Keycloak service: $KEYCLOAK_SERVICE_NAME:$KEYCLOAK_SERVICE_PORT"

                start_port_forward "${CAMUNDA_RELEASE_NAME}-zeebe-gateway" 8080:8080

                # Setup Keycloak port-forwarding with dynamic port
                start_port_forward "$KEYCLOAK_SERVICE_NAME" "18080:$KEYCLOAK_SERVICE_PORT"

                echo "Waiting for port-forwarding to be established..." && sleep 10
              else
                # With domain:
                source ./generic/kubernetes/single-region/procedure/export-verify-zeebe-domain.sh
              fi

              # Execute the script and capture the output in a variable
              eval "$topology_check_script"
              check_zeebe_topology_output=$(<zeebe-topology.json)

              # Checks
              error_found=false
              check_zeebe_topology_all_healthy=$(echo "$check_zeebe_topology_output" | jq '[.brokers[].partitions[].health == "healthy"] | all')
              check_zeebe_topology_cluster_size=$(echo "$check_zeebe_topology_output" | jq '.clusterSize')
              check_zeebe_topology_partitions_count=$(echo "$check_zeebe_topology_output" | jq '.partitionsCount')

              golden_zeebe_topology_cluster_size=$(jq '.clusterSize' < "$reference_file")
              golden_zeebe_topology_partitions_count=$(jq '.partitionsCount' < "$reference_file")

              if [ "$check_zeebe_topology_all_healthy" = "true" ]; then
                echo "‚úÖ All partitions are healthy."
              else
                echo "‚ùå Not all partitions are healthy"
                error_found=true
              fi

              if [ "$check_zeebe_topology_cluster_size" -eq $golden_zeebe_topology_cluster_size ]; then
                echo "‚úÖ Cluster size is $check_zeebe_topology_cluster_size."
              else
                echo "‚ùå Cluster size is not $golden_zeebe_topology_cluster_size."
                error_found=true
              fi

              if [ "$check_zeebe_topology_partitions_count" -eq $golden_zeebe_topology_partitions_count ]; then
                echo "‚úÖ Partitions count is $check_zeebe_topology_partitions_count."
              else
                echo "‚ùå Partitions count is not $golden_zeebe_topology_partitions_count."
                error_found=true
              fi

              echo "Comparing golden file of the zeebe topology output..."

              # Save the output to a temporary file
              temp_output=$(mktemp)
              echo "$check_zeebe_topology_output" > "$temp_output"

              # Replace patch version
              yq e '.brokers[].version |= sub("[.].*$", ".z") | .gatewayVersion |= sub("[.].*$", ".z")' -i "$temp_output"
              yq e '.brokers[].version |= sub("[.].*$", ".z") | .gatewayVersion |= sub("[.].*$", ".z")' -i "$reference_file"

              # Replace clusterId with fixed value
              yq e '.clusterId = "zzzzzz-xxxxx-yyyy-dddd-cccc"' -i "$temp_output"
              yq e '.clusterId = "zzzzzz-xxxxx-yyyy-dddd-cccc"' -i "$reference_file"

              # Replace namespace names with cluster names if env vars are set
              if [[ -n "${CLUSTER_2_NAME:-}" && -n "${CAMUNDA_NAMESPACE_2:-}" && -n "${CAMUNDA_NAMESPACE_1:-}" ]]; then
                echo "Replacing namespace values in golden file..."
                sed -e "s/cluster-region-2/$CLUSTER_2_NAME/g" \
                    -e "s/camunda-cluster-region-2\.svc/$CAMUNDA_NAMESPACE_2\.svc/g" \
                    -e "s/camunda-cluster-region-1\.svc/$CAMUNDA_NAMESPACE_1\.svc/g" \
                    -i "$reference_file"
              fi

              echo "Replacing release name value in golden file..."
              sed -e "s/camunda-zeebe/${CAMUNDA_RELEASE_NAME}-zeebe/g" -i "$reference_file"

              # Order each file also remove not predictable fields
              yq e '.brokers |= sort_by(.host) | .brokers[] |= (.partitions |= sort_by(.partitionId) | .partitions[].role = "NOT_PREDICTABLE")' -i "$temp_output"
              yq e '.brokers |= sort_by(.host) | .brokers[] |= (.partitions |= sort_by(.partitionId) | .partitions[].role = "NOT_PREDICTABLE")' -i "$reference_file"

              # Compare the two files using diff (in compacted JSON format)
              diff_output=$(delta <(jq -S . "$temp_output") <(jq -S . "$reference_file") || true)

              if [[ -n "$diff_output" ]]; then
                # If differences are found, print the error and the diff
                echo "‚ùå Error: The golden files of zeebe topology files do not match."
                echo "Differences found:"
                echo "$diff_output"

                # Display the new generated version
                echo "New version:"
                cat "$temp_output"

                error_found=true
              fi

              if [ "$error_found" = true ]; then
                echo "‚ùå Some tests failed."
                exit 1
              fi
              echo "‚úÖ The cluster meets all the expected criteria."

        - name: üß™ C8-SM-CHECKS - Run Deployment Check
          if: ${{ inputs.enable-c8sm-deployment-check == 'true' }}
          shell: bash
          env:
              NAMESPACE: ${{ inputs.test-namespace }}
              HELM_DEPLOYMENT_NAME: ${{ inputs.test-release-name }}
          run: |
              set -euo pipefail

              echo "üîç Running deployment check..."

              # Determine required containers based on what's enabled and Camunda version
              # For Camunda 8.8+, zeebe components are unified under 'orchestration'
              CAMUNDA_MAJOR_VERSION=$(echo "${{ inputs.camunda-version }}" | cut -d. -f1)
              CAMUNDA_MINOR_VERSION=$(echo "${{ inputs.camunda-version }}" | cut -d. -f2)

              # Camunda 8.8+ uses 'zeebe' instead of 'zeebe,zeebe-gateway'
              REQUIRED_CONTAINERS="connector,optimize,zeebe"

              if [[ "${{ inputs.webmodeler-enabled }}" == "true" ]]; then
                REQUIRED_CONTAINERS="${REQUIRED_CONTAINERS},web-modeler"
              fi

              if [[ "${{ inputs.console-enabled }}" == "true" ]]; then
                REQUIRED_CONTAINERS="${REQUIRED_CONTAINERS},console"
              fi

              echo "Required containers for Camunda ${{ inputs.camunda-version }}: $REQUIRED_CONTAINERS"

              C8_SM_CHECKS_PATH="${{ inputs.tests-c8-sm-checks-repo-path }}"
              chmod +x "$C8_SM_CHECKS_PATH/checks/kube/deployment.sh"
              "$C8_SM_CHECKS_PATH/checks/kube/deployment.sh" \
                -n "$NAMESPACE" \
                -d "$HELM_DEPLOYMENT_NAME" \
                -c "$REQUIRED_CONTAINERS"

        - name: üß™ C8-SM-CHECKS - Run Kubernetes Connectivity Check
          if: ${{ inputs.enable-c8sm-connectivity-check == 'true' }}
          shell: bash
          env:
              NAMESPACE: ${{ inputs.test-namespace }}
              CAMUNDA_DOMAIN: ${{ inputs.camunda-domain }}
          run: |
              set -euo pipefail

              echo "üîç Running Kubernetes connectivity check..."

              C8_SM_CHECKS_PATH="${{ inputs.tests-c8-sm-checks-repo-path }}"
              chmod +x "$C8_SM_CHECKS_PATH/checks/kube/connectivity.sh"

              # Skip ingress checks if no domain is configured
              if [[ -z "$CAMUNDA_DOMAIN" ]] || [[ "${{ inputs.skip-c8sm-connectivity-ingress-class-check }}" == "true" ]]; then
                echo "‚ÑπÔ∏è No domain configured, skipping ingress checks"
                "$C8_SM_CHECKS_PATH/checks/kube/connectivity.sh" -n "$NAMESPACE" -i
              else
                "$C8_SM_CHECKS_PATH/checks/kube/connectivity.sh" -n "$NAMESPACE"
              fi

        - name: üß™ C8-SM-CHECKS - Run AWS IRSA Check
          if: ${{ inputs.enable-c8sm-irsa-check == 'true' }}
          shell: bash
          env:
              NAMESPACE: ${{ inputs.test-namespace }}
              ELASTICSEARCH_ENABLED: ${{ inputs.elasticsearch-enabled }}
          run: |
              set -euo pipefail

              echo "üîç Running AWS IRSA check..."

              C8_SM_CHECKS_PATH="${{ inputs.tests-c8-sm-checks-repo-path }}"
              chmod +x "$C8_SM_CHECKS_PATH/checks/kube/aws-irsa.sh"

              # Exclude components based on configuration
              if [[ "$ELASTICSEARCH_ENABLED" == "true" ]]; then
                # If Elasticsearch is enabled, IRSA won't work with OpenSearch
                echo "‚ö†Ô∏è Elasticsearch is enabled, skipping IRSA checks"
                exit 0
              fi

              # Build component lists based on Camunda version
              CAMUNDA_MAJOR_VERSION=$(echo "${{ inputs.camunda-version }}" | cut -d. -f1)
              CAMUNDA_MINOR_VERSION=$(echo "${{ inputs.camunda-version }}" | cut -d. -f2)

              # Camunda 8.8+ uses 'orchestration' and 'optimize' for OpenSearch
              OS_COMPONENTS="orchestration,optimize"

              PG_COMPONENTS="identityKeycloak,identity"

              if [[ "${{ inputs.webmodeler-enabled }}" == "true" ]]; then
                PG_COMPONENTS="${PG_COMPONENTS},webModeler"
              fi

              echo "OpenSearch components: $OS_COMPONENTS"
              echo "PostgreSQL components: $PG_COMPONENTS"

              "$C8_SM_CHECKS_PATH/checks/kube/aws-irsa.sh" \
                -n "$NAMESPACE" \
                -p "$PG_COMPONENTS" \
                -l "$OS_COMPONENTS"

        - name: üîß Configure /etc/hosts for local domain mode
          if: ${{ inputs.local-domain-mode == 'true' && inputs.camunda-domain != '' }}
          shell: bash
          env:
              CAMUNDA_DOMAIN: ${{ inputs.camunda-domain }}
              CAMUNDA_DOMAIN_GRPC: ${{ inputs.camunda-domain-grpc }}
              LOCAL_DOMAIN_IP: ${{ inputs.local-domain-ip }}
          run: |
              set -euo pipefail

              echo "üîß Configuring /etc/hosts for local domain mode..."
              echo "   Using IP: $LOCAL_DOMAIN_IP"

              # Add main Camunda domain
              if [[ -n "$CAMUNDA_DOMAIN" ]]; then
                echo "Adding hosts entry: $LOCAL_DOMAIN_IP $CAMUNDA_DOMAIN"
                echo "$LOCAL_DOMAIN_IP $CAMUNDA_DOMAIN" | sudo tee -a /etc/hosts
              fi

              # Add gRPC domain if different from main domain
              # Extract hostname from port if present (e.g., zeebe-camunda.example.com:443 -> zeebe-camunda.example.com)
              if [[ -n "$CAMUNDA_DOMAIN_GRPC" ]]; then
                GRPC_HOST="${CAMUNDA_DOMAIN_GRPC%%:*}"
                if [[ "$GRPC_HOST" != "$CAMUNDA_DOMAIN" ]]; then
                  echo "Adding hosts entry: $LOCAL_DOMAIN_IP $GRPC_HOST"
                  echo "$LOCAL_DOMAIN_IP $GRPC_HOST" | sudo tee -a /etc/hosts
                fi
              fi

              echo ""
              echo "‚úÖ /etc/hosts configured for local domain mode:"
              grep -E "($CAMUNDA_DOMAIN|${CAMUNDA_DOMAIN_GRPC%%:*})" /etc/hosts || true

        - name: üß™ C8-SM-CHECKS - Run Zeebe Token Generation Check
          if: ${{ inputs.enable-c8sm-zeebe-token-check == 'true' && inputs.zeebe-authenticated == 'true' && inputs.camunda-domain != '' }}
          shell: bash
          env:
              ZEEBE_AUTHORIZATION_SERVER_URL: ${{ format('https://{0}/auth/realms/camunda-platform/protocol/openid-connect/token', inputs.camunda-domain)
                  }}
              ZEEBE_CLIENT_ID: ${{ inputs.test-client-id }}
              ZEEBE_CLIENT_SECRET: ${{ inputs.test-client-secret }}
              ZEEBE_TOKEN_AUDIENCE: orchestration-api
          run: |
              set -euo pipefail

              echo "üîç Running Zeebe token generation check..."

              C8_SM_CHECKS_PATH="${{ inputs.tests-c8-sm-checks-repo-path }}"
              chmod +x "$C8_SM_CHECKS_PATH/checks/zeebe/token.sh"

              "$C8_SM_CHECKS_PATH/checks/zeebe/token.sh" \
                -a "$ZEEBE_AUTHORIZATION_SERVER_URL" \
                -i "$ZEEBE_CLIENT_ID" \
                -s "$ZEEBE_CLIENT_SECRET" \
                -u "$ZEEBE_TOKEN_AUDIENCE"

        - name: üß™ C8-SM-CHECKS - Run Zeebe Connectivity Check
          if: ${{ inputs.enable-c8sm-zeebe-connectivity-check == 'true' && inputs.enable-zeebe-client-tests == 'true' && inputs.camunda-domain != '' }}
          shell: bash
          env:
              ZEEBE_ADDRESS: ${{ inputs.camunda-domain-grpc || format('{0}:443', inputs.camunda-domain) }}
              ZEEBE_AUTHORIZATION_SERVER_URL: ${{ format('https://{0}/auth/realms/camunda-platform/protocol/openid-connect/token', inputs.camunda-domain)
                  }}
              ZEEBE_CLIENT_ID: ${{ inputs.test-client-id }}
              ZEEBE_CLIENT_SECRET: ${{ inputs.test-client-secret }}
              ZEEBE_TOKEN_AUDIENCE: orchestration-api
              ZEEBE_DEFAULT_VERSION: ${{ inputs.camunda-version }}
          run: |
              set -euo pipefail

              echo "üîç Running Zeebe connectivity check..."

              C8_SM_CHECKS_PATH="${{ inputs.tests-c8-sm-checks-repo-path }}"
              chmod +x "$C8_SM_CHECKS_PATH/checks/zeebe/connectivity.sh"

              "$C8_SM_CHECKS_PATH/checks/zeebe/connectivity.sh" \
                -H "$ZEEBE_ADDRESS" \
                -p "$ZEEBE_DEFAULT_VERSION" \
                -a "$ZEEBE_AUTHORIZATION_SERVER_URL" \
                -i "$ZEEBE_CLIENT_ID" \
                -s "$ZEEBE_CLIENT_SECRET" \
                -u "$ZEEBE_TOKEN_AUDIENCE" \
                -q grpc
