---
name: Deploy AWS Kubernetes EKS Single Region Cluster

description: |
    This GitHub Action automates the deployment of the aws/kubernetes/eks-single-region(-irsa) reference architecture cluster using Terraform.
    The kube context will be set on the created cluster.
    Supports conditional deployment of Aurora PostgreSQL and OpenSearch.

inputs:
    cluster-name:
        description: Name of the EKS cluster to deploy
        required: true
    aws-region:
        description: AWS region where the EKS cluster will be deployed
        required: true
    kubernetes-version:
        description: Version of Kubernetes to install
        required: false
        # renovate: datasource=endoflife-date depName=amazon-eks versioning=loose
        default: '1.32'
    single-nat-gateway:
        description: Whether to use a single NAT gateway or not. Default is true for our tests to save on IPs.
        default: 'true'
    tags:
        description: Tags to apply to the cluster and related resources, in JSON format
        default: '{}'
    s3-backend-bucket:
        description: Name of the S3 bucket to store Terraform state
        required: true
    s3-bucket-region:
        description: Region of the bucket containing the resources states, if not set, will fallback on aws-region
    s3-bucket-key-prefix:
        description: Key prefix of the bucket containing the resources states. It must contain a / at the end e.g 'my-prefix/'.
        default: ''
    tf-modules-revision:
        description: Git revision of the tf modules to use
        default: main
        required: true
    tf-modules-path:
        description: Path where the tf eks modules will be cloned
        default: ./.action-tf-modules/aws-kubernetes-eks-single-region-create/
        required: true
    login:
        description: Authenticate the current kube context on the created cluster
        default: 'true'
        required: true
    ref-arch:
        description: Reference architecture to deploy
        default: eks-single-region-irsa
        required: false
    vpn-enabled:
        description: Enable VPN setup module (recommended when private_vpc is true), this will also configure the current runner to use it
        default: 'false'
    private-vpc:
        description: The VPC within which the cluster resides will only have private subnets, meaning that it cannot be accessed at all from the public
            Internet (empty will fallback on default value of the module)
        default: ''
    deploy-aurora:
        description: Deploy Aurora PostgreSQL database
        default: 'true'
    deploy-opensearch:
        description: Deploy OpenSearch domain
        default: 'true'

outputs:
    terraform-state-url-cluster:
        description: URL of the Terraform state file in the S3 bucket
        value: ${{ steps.init-cluster.outputs.terraform-state-url-cluster }}


    terraform-state-url-vpn:
        description: URL of the module "vpn" Terraform state file in the S3 bucket
        value: ${{ steps.init-vpn.outputs.terraform-state-url-vpn }}


    vpn-client-configs:
        description: Map of VPN client configs
        value: ${{ steps.apply-vpn.outputs.vpn_client_configs || '' }}
    vpn-client-config-file:
        description: Config file used by the VPN
        value: ${{ steps.vpn.outputs.vpn_client_config_file || '' }}
    vpn-endpoint:
        description: Endpoint of the VPN to access the created cluster
        value: ${{ steps.apply-vpn.outputs.vpn_endpoint || '' }}

runs:
    using: composite
    steps:
        - name: Checkout Repository
          uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
          with:
              repository: camunda/camunda-deployment-references
              ref: ${{ inputs.tf-modules-revision }}
              path: ${{ inputs.tf-modules-path }}
              fetch-depth: 0

        - name: Install asdf tools with cache for the project
          uses: camunda/infraex-common-config/./.github/actions/asdf-install-tooling@eb9d51b4dc89deeda7fc160166f378725ee0f06a # 1.5.3

        - name: Set Terraform variables
          id: set-terraform-variables
          shell: bash
          run: |
              set -euo pipefail
              export TFSTATE_BUCKET="${{ inputs.s3-backend-bucket }}"
              export TFSTATE_BASE_KEY="${{ inputs.s3-bucket-key-prefix }}tfstate-${{ inputs.cluster-name }}/"

              if [ -z "${{ inputs.s3-bucket-region }}" ]; then
                export TFSTATE_REGION="$AWS_REGION"
              else
                export TFSTATE_REGION="${{ inputs.s3-bucket-region }}"
              fi

              echo "TFSTATE_BUCKET=${TFSTATE_BUCKET}" >> "$GITHUB_OUTPUT"
              echo "TFSTATE_REGION=${TFSTATE_REGION}" >> "$GITHUB_OUTPUT"
              echo "TFSTATE_BASE_KEY=${TFSTATE_BASE_KEY}" | tee -a "$GITHUB_OUTPUT"


        - name: Sanitize Tags
          id: sanitize-tags
          uses: ./.github/actions/internal-sanitize-tags
          with:
              raw-tags: ${{ inputs.tags }}

        - name: Terraform Init - Cluster
          id: init-cluster
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/cluster/
          shell: bash
          run: |
              set -euo pipefail

              terraform_state_key="${{ steps.set-terraform-variables.outputs.TFSTATE_BASE_KEY }}cluster.tfstate"
              terraform_state_url_cluster="s3://${{ steps.set-terraform-variables.outputs.TFSTATE_BUCKET }}/$terraform_state_key"
              echo "terraform-state-url-cluster=${terraform_state_url_cluster}" | tee -a "$GITHUB_OUTPUT"

              terraform version

              terraform init \
                -backend-config="bucket=${{ steps.set-terraform-variables.outputs.TFSTATE_BUCKET }}" \
                -backend-config="key=$terraform_state_key" \
                -backend-config="region=${{ steps.set-terraform-variables.outputs.TFSTATE_REGION }}"

              terraform validate -no-color

        - name: Generate tfvars file - Cluster
          id: generate-tfvars-cluster
          shell: bash
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/cluster/
          run: |
              set -euo pipefail

              cat > terraform-cluster.tfvars <<EOF
              default_tags = ${{ steps.sanitize-tags.outputs.sanitized_tags }}
              EOF

        - name: Terraform Plan - Cluster
          id: plan-cluster
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/cluster/
          shell: bash
          run: |
              set -euo pipefail
              echo "Adapting the files with input values"
              pwd
              ls

              # We use sed instead of -var because the module presented to the user
              # uses locals for simplicity. Locals cannot be overwritten with the CLI.
              sed -i -e 's/\(eks_cluster_name\s*=\s*"\)[^"]*\("\)/\1${{ inputs.cluster-name }}\2/' \
                     -e 's/\(eks_cluster_region\s*=\s*"\)[^"]*\("\)/\1${{ inputs.aws-region }}\2/' \
                     -e 's/\(kubernetes_version\s*=\s*"\)[^"]*\("\)/\1${{ inputs.kubernetes-version }}\2/' \
                     -e 's/\(single_nat_gateway\s*=\s*"\)[^"]*\("\)/\1${{ inputs.single-nat-gateway }}\2/' \
                     cluster.tf

              if [ -n "${{ inputs.private-vpc }}" ]; then
                sed -i -E "s/(^\s*private_vpc\s*=\s*)[a-z]+/\1${{ inputs.private-vpc }}/" cluster.tf
              else
                echo "No private-vpc value provided, skipping private modification."
              fi

              echo "Displaying templated cluster.tf file:"
              cat cluster.tf

              # Conditionally configure Aurora PostgreSQL
              if [[ "${{ inputs.deploy-aurora }}" == "true" ]]; then
                  echo "Configuring Aurora PostgreSQL database..."
                  sed -i -e 's/\(aurora_cluster_name\s*=\s*"\)[^"]*\("\)/\1${{ inputs.cluster-name }}-pg\2/' \
                         db.tf
                  echo "Displaying templated db.tf file:"
                  cat db.tf
              else
                  echo "Skipping Aurora PostgreSQL deployment"
                  # Comment out or remove Aurora resources
                  if [[ -f "db.tf" ]]; then
                      mv db.tf db.tf.disabled
                      echo "Aurora resources disabled"
                  fi
              fi

              # Conditionally configure OpenSearch
              if [[ "${{ inputs.deploy-opensearch }}" == "true" ]]; then
                  echo "Configuring OpenSearch domain..."
                  sed -i -e 's/\(opensearch_domain_name\s*=\s*"\)[^"]*\("\)/\1${{ inputs.cluster-name }}-os\2/' \
                         opensearch.tf
                  echo "Displaying templated opensearch.tf file:"
                  cat opensearch.tf
              else
                  echo "Skipping OpenSearch deployment"
                  # Comment out or remove OpenSearch resources
                  if [[ -f "opensearch.tf" ]]; then
                      mv opensearch.tf opensearch.tf.disabled
                      echo "OpenSearch resources disabled"
                  fi
              fi

              terraform plan -no-color -var-file=terraform-cluster.tfvars -out tf.plan

        - name: Terraform Apply - Cluster
          id: apply-cluster
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/cluster/
          shell: bash
          run: |
              set -euo pipefail
              terraform apply -no-color tf.plan

              export vpc_id="$(terraform output -raw vpc_id)"
              echo "vpc_id=$vpc_id" | tee -a "$GITHUB_OUTPUT"

        - name: Terraform Drift Detection - Cluster
          if: 'false' # TODO: remove, just for testing purposes
          uses: ./.github/actions/internal-terraform-drift-detect
          id: drift-detect-cluster
          with:
              working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/cluster/
              plan-extra-args: |
                  -var-file=terraform-cluster.tfvars

        - name: Terraform Init - VPN
          id: init-vpn
          if: inputs.vpn-enabled == 'true'
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/vpn/
          shell: bash
          run: |
              set -euo pipefail

              terraform_state_key="${{ steps.set-terraform-variables.outputs.TFSTATE_BASE_KEY }}vpn.tfstate"
              terraform_state_url_vpn="s3://${{ steps.set-terraform-variables.outputs.TFSTATE_BUCKET }}/$terraform_state_key"
              echo "terraform-state-url-cluster=${terraform_state_url_vpn}" | tee -a "$GITHUB_OUTPUT"

              terraform version

              terraform init \
                -backend-config="bucket=${{ steps.set-terraform-variables.outputs.TFSTATE_BUCKET }}" \
                -backend-config="key=$terraform_state_key" \
                -backend-config="region=${{ steps.set-terraform-variables.outputs.TFSTATE_REGION }}"

              terraform validate -no-color

        - name: Generate tfvars file - VPN
          id: generate-tfvars-vpn
          if: inputs.vpn-enabled == 'true'
          shell: bash
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/vpn/
          run: |
              set -euo pipefail

              cat > terraform-vpn.tfvars <<EOF
              default_tags = ${{ steps.sanitize-tags.outputs.sanitized_tags }}
              vpc_id = "${{ steps.apply-cluster.outputs.vpc_id }}"
              EOF

        - name: Terraform Plan - VPN
          id: plan-vpn
          if: inputs.vpn-enabled == 'true'
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/vpn/
          shell: bash
          run: |
              set -euo pipefail

              echo "Adapting the files with input values"
              pwd
              ls

              sed -i -E \
                -e "s/(^\s*vpn_name\s*=\s*\")[^\"]*(\")/\1${{ inputs.cluster-name }}-vpn\2/" \
                vpn.tf

              echo "Displaying templated vpn.tf file:"
              cat vpn.tf

              terraform plan -no-color -var-file=terraform-vpn.tfvars -out vpn.plan

        - name: Terraform Apply - VPN
          id: apply-vpn
          if: inputs.vpn-enabled == 'true'
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/vpn/
          shell: bash
          run: |
              set -euo pipefail

              terraform apply -no-color vpn.plan

              export vpn_client_configs="$(terraform output -json vpn_client_configs)"
              echo "vpn_client_configs=$vpn_client_configs" >> "$GITHUB_OUTPUT"
              echo "::add-mask::$vpn_client_configs"

              echo "vpn_endpoint=$(terraform output -json vpn_endpoint)" | tee -a "$GITHUB_OUTPUT"

        - name: Terraform Drift Detection - VPN
          uses: ./.github/actions/internal-terraform-drift-detect
          if: inputs.vpn-enabled == 'true'
          id: drift-detect-vpn
          with:
              working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/vpn/
              plan-extra-args: |
                  -var-file=terraform-vpn.tfvars

        ### End of terraform

        - name: Configure VPN Client if enabled
          id: vpn
          shell: bash
          if: inputs.vpn-enabled == 'true'
          run: |
              sudo apt update
              sudo apt install -y openvpn openvpn-systemd-resolved

              client_name="my-client" # the client name is hard-coded in the reference
              config=$(echo '${{ steps.apply-vpn.outputs.vpn_client_configs }}' | jq -r --arg client "$client_name" '.[$client]')

              # Create a secure directory inside the GitHub workspace
              mkdir -p "$GITHUB_WORKSPACE/.vpn"
              vpn_client_config_file="$GITHUB_WORKSPACE/.vpn/client.ovpn"

              # Create the client's config file
              echo "$config" > "$vpn_client_config_file"
              echo "vpn_client_config_file=$vpn_client_config_file" | tee -a "$GITHUB_OUTPUT"

        - name: Connect to VPN
          if: inputs.vpn-enabled == 'true'
          uses: kota65535/github-openvpn-connect-action@cd2ed8a90cc7b060dc4e001143e811b5f7ea0af5 # v3.1.0
          with:
              config_file: ${{ steps.vpn.outputs.vpn_client_config_file }}
              echo_config: 'false'

        - name: Login and generate kubeconfig
          if: inputs.login == 'true'
          shell: bash
          run: |
              set -euo pipefail
              aws eks update-kubeconfig --region ${{ inputs.aws-region }} --name ${{ inputs.cluster-name }} --alias ${{ inputs.cluster-name }}

              kubectl config current-context
              kubectl get nodes

        - name: Apply and verify storage class
          shell: bash
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/
          run: |
              set -euo pipefail
              ./procedure/storageclass-configure.sh
              ./procedure/storageclass-verify.sh
