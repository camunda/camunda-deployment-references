---
name: Deploy AWS Kubernetes EKS Single Region Cluster

description: |
    This GitHub Action automates the deployment of the aws/kubernetes/eks-single-region(-irsa) reference architecture cluster using Terraform.
    The kube context will be set on the created cluster.

inputs:
    cluster-name:
        description: Name of the EKS cluster to deploy
        required: true
    aws-region:
        description: AWS region where the EKS cluster will be deployed
        required: true
    kubernetes-version:
        description: Version of Kubernetes to install
        required: false
        # renovate: datasource=endoflife-date depName=amazon-eks versioning=loose
        default: '1.32'
    single-nat-gateway:
        description: Whether to use a single NAT gateway or not. Default is true for our tests to save on IPs.
        default: 'true'
    tags:
        description: Tags to apply to the cluster and related resources, in JSON format
        default: '{}'
    s3-backend-bucket:
        description: Name of the S3 bucket to store Terraform state
        required: true
    s3-bucket-region:
        description: Region of the bucket containing the resources states, if not set, will fallback on aws-region
    s3-bucket-key-prefix:
        description: Key prefix of the bucket containing the resources states. It must contain a / at the end e.g 'my-prefix/'.
        default: ''
    tf-modules-revision:
        description: Git revision of the tf modules to use
        default: main
        required: true
    tf-modules-path:
        description: Path where the tf eks modules will be cloned
        default: ./.action-tf-modules/aws-kubernetes-eks-single-region-create/
        required: true
    login:
        description: Authenticate the current kube context on the created cluster
        default: 'true'
        required: true
    ref-arch:
        description: Reference architecture to deploy
        default: eks-single-region-irsa
        required: false
    vpn-enabled:
        description: Enable VPN setup module (recommended when private_vpc is true), this will also configure the current runner to use it
        default: 'false'
    private-vpc:
        description: The VPC within which the cluster resides will only have private subnets, meaning that it cannot be accessed at all from the public
            Internet (empty will fallback on default value of the module)
        default: ''

outputs:
    terraform-state-url-cluster:
        description: URL of the Terraform state file in the S3 bucket
        value: ${{ steps.init-cluster.outputs.terraform-state-url-cluster }}


    terraform-state-url-vpn:
        description: URL of the module "vpn" Terraform state file in the S3 bucket
        value: ${{ steps.init-vpn.outputs.terraform-state-url-vpn }}


    vpn-client-configs:
        description: Map of VPN client configs
        value: ${{ steps.apply-vpn.outputs.vpn_client_configs || '' }}
    vpn-client-config-file:
        description: Config file used by the VPN
        value: ${{ steps.vpn.outputs.vpn_client_config_file || '' }}
    vpn-endpoint:
        description: Endpoint of the VPN to access the created cluster
        value: ${{ steps.apply-vpn.outputs.vpn_endpoint || '' }}

runs:
    using: composite
    steps:
        - name: Checkout Repository
          uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4
          with:
              repository: camunda/camunda-deployment-references
              ref: ${{ inputs.tf-modules-revision }}
              path: ${{ inputs.tf-modules-path }}
              fetch-depth: 0

        - name: Install asdf tools with cache for the project
          uses: camunda/infraex-common-config/./.github/actions/asdf-install-tooling@cb673a2ce24ba79afed0507f3d245cdecf17337f # 1.4.8

        - name: Set Terraform variables
          id: set-terraform-variables
          shell: bash
          run: |
              set -euo pipefail
              export TFSTATE_BUCKET="${{ inputs.s3-backend-bucket }}"
              export TFSTATE_BASE_KEY="${{ inputs.s3-bucket-key-prefix }}tfstate-${{ inputs.cluster-name }}/"

              if [ -z "${{ inputs.s3-bucket-region }}" ]; then
                export TFSTATE_REGION="$AWS_REGION"
              else
                export TFSTATE_REGION="${{ inputs.s3-bucket-region }}"
              fi

              echo "TFSTATE_BUCKET=${TFSTATE_BUCKET}" >> "$GITHUB_OUTPUT"
              echo "TFSTATE_REGION=${TFSTATE_REGION}" >> "$GITHUB_OUTPUT"
              echo "TFSTATE_BASE_KEY=${TFSTATE_BASE_KEY}" | tee -a "$GITHUB_OUTPUT"


        - name: Sanitize Tags
          id: sanitize-tags
          uses: ./.github/actions/internal-sanitize-tags
          with:
              raw-tags: ${{ inputs.tags }}

        - name: Terraform Init - Cluster
          id: init-cluster
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/cluster/
          shell: bash
          run: |
              set -euo pipefail

              terraform_state_key="${{ steps.set-terraform-variables.outputs.TFSTATE_BASE_KEY }}cluster.tfstate"
              terraform_state_url_cluster="s3://${{ steps.set-terraform-variables.outputs.TFSTATE_BUCKET }}/$terraform_state_key"
              echo "terraform-state-url-cluster=${terraform_state_url_cluster}" | tee -a "$GITHUB_OUTPUT"

              terraform version

              terraform init \
                -backend-config="bucket=${{ steps.set-terraform-variables.outputs.TFSTATE_BUCKET }}" \
                -backend-config="key=$terraform_state_key" \
                -backend-config="region=${{ steps.set-terraform-variables.outputs.TFSTATE_REGION }}"

              terraform validate -no-color

        - name: Terraform Plan - Cluster
          id: plan-cluster
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/terraform/cluster/${{ inputs.ref-arch }}/
          shell: bash
          run: |
              set -euo pipefail
              echo "Adapting the files with input values"
              pwd
              ls

              # We use sed instead of -var because the module presented to the user
              # uses locals for simplicity. Locals cannot be overwritten with the CLI.
              sed -i -e 's/\(eks_cluster_name\s*=\s*"\)[^"]*\("\)/\1${{ inputs.cluster-name }}\2/' \
                     -e 's/\(eks_cluster_region\s*=\s*"\)[^"]*\("\)/\1${{ inputs.aws-region }}\2/' \
                     -e 's/\(kubernetes_version\s*=\s*"\)[^"]*\("\)/\1${{ inputs.kubernetes-version }}\2/' \
                     -e 's/\(single_nat_gateway\s*=\s*"\)[^"]*\("\)/\1${{ inputs.single-nat-gateway }}\2/' \
                     cluster.tf

              if [ -n "${{ inputs.private-vpc }}" ]; then
                sed -i -E "s/(^\s*private_vpc\s*=\s*)[a-z]+/\1${{ inputs.private-vpc }}/" cluster.tf
              else
                echo "No private-vpc value provided, skipping private modification."
              fi

              echo "Displaying templated cluster.tf file:"
              cat cluster.tf

              sed -i -e 's/\(aurora_cluster_name\s*=\s*"\)[^"]*\("\)/\1${{ inputs.cluster-name }}-pg\2/' \
                     db.tf

              echo "Displaying templated db.tf file:"
              cat db.tf

              sed -i -e 's/\(opensearch_domain_name\s*=\s*"\)[^"]*\("\)/\1${{ inputs.cluster-name }}-os\2/' \
                     opensearch.tf

              echo "Displaying templated opensearch.tf file:"
              cat opensearch.tf

              terraform plan -no-color -var='default_tags=${{ steps.sanitize-tags.outputs.sanitized_tags }}' -out tf.plan

        - name: Terraform Apply - Cluster
          id: apply-cluster
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/cluster/
          shell: bash
          run: |
              set -euo pipefail
              terraform apply -no-color tf.plan

              export vpc_id="$(terraform output -raw vpc_id)"
              echo "vpc_id=$vpc_id" | tee -a "$GITHUB_OUTPUT"

        - name: Terraform Init - VPN
          id: init-vpn
          if: inputs.vpn-enabled == 'true'
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/vpn/
          shell: bash
          run: |
              set -euo pipefail

              terraform_state_key="${{ steps.set-terraform-variables.outputs.TFSTATE_BASE_KEY }}vpn.tfstate"
              terraform_state_url_vpn="s3://${{ steps.set-terraform-variables.outputs.TFSTATE_BUCKET }}/$terraform_state_key"
              echo "terraform-state-url-cluster=${terraform_state_url_vpn}" | tee -a "$GITHUB_OUTPUT"

              terraform version

              terraform init \
                -backend-config="bucket=${{ steps.set-terraform-variables.outputs.TFSTATE_BUCKET }}" \
                -backend-config="key=$terraform_state_key" \
                -backend-config="region=${{ steps.set-terraform-variables.outputs.TFSTATE_REGION }}"

              terraform validate -no-color

        - name: Terraform Plan - VPN
          id: plan-vpn
          if: inputs.vpn-enabled == 'true'
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/vpn/
          shell: bash
          run: |
              set -euo pipefail

              echo "Adapting the files with input values"
              pwd
              ls

              sed -i -E \
                -e "s/(^\s*vpn_name\s*=\s*\")[^\"]*(\")/\1${{ inputs.cluster-name }}-vpn\2/" \
                vpn.tf

              echo "Displaying templated vpn.tf file:"
              cat vpn.tf

              terraform plan -no-color \
                -var='default_tags=${{ steps.sanitize-tags.outputs.sanitized_tags }}' \
                -var="vpc_id=${{ steps.apply-cluster.outputs.vpc_id }}" \
                -out vpn.plan

        - name: Terraform Apply - VPN
          id: apply-vpn
          if: inputs.vpn-enabled == 'true'
          working-directory: ${{ inputs.tf-modules-path }}/aws/kubernetes/${{ inputs.ref-arch }}/terraform/vpn/
          shell: bash
          run: |
              set -euo pipefail

              terraform apply -no-color vpn.plan

              export vpn_client_configs="$(terraform output -json vpn_client_configs)"
              echo "vpn_client_configs=$vpn_client_configs" >> "$GITHUB_OUTPUT"
              echo "::add-mask::$vpn_client_configs"

              echo "vpn_endpoint=$(terraform output -json vpn_endpoint)" | tee -a "$GITHUB_OUTPUT"

        ### End of terraform

        - name: Configure VPN Client if enabled
          id: vpn
          shell: bash
          if: inputs.vpn-enabled == 'true'
          run: |
              sudo apt update
              sudo apt install -y openvpn openvpn-systemd-resolved

              client_name="my-client" # the client name is hard-coded in the reference
              config=$(echo '${{ steps.apply-vpn.outputs.vpn_client_configs }}' | jq -r --arg client "$client_name" '.[$client]')

              # Create a secure directory inside the GitHub workspace
              mkdir -p "$GITHUB_WORKSPACE/.vpn"
              vpn_client_config_file="$GITHUB_WORKSPACE/.vpn/client.ovpn"

              # Create the client's config file
              echo "$config" > "$vpn_client_config_file"
              echo "vpn_client_config_file=$vpn_client_config_file" | tee -a "$GITHUB_OUTPUT"

        - name: Connect to VPN
          if: inputs.vpn-enabled == 'true'
          uses: kota65535/github-openvpn-connect-action@cd2ed8a90cc7b060dc4e001143e811b5f7ea0af5 # v3.1.0
          with:
              config_file: ${{ steps.vpn.outputs.vpn_client_config_file }}
              echo_config: 'false'


        - name: Login and generate kubeconfig
          if: inputs.login == 'true'
          shell: bash
          run: |
              set -euo pipefail
              aws eks update-kubeconfig --region ${{ inputs.aws-region }} --name ${{ inputs.cluster-name }} --alias ${{ inputs.cluster-name }}

              kubectl config current-context
              kubectl get nodes
