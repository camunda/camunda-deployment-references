---
name: Deploy Keycloak via Operator
description: |
    Deploys Keycloak using the Keycloak Operator with CloudNativePG PostgreSQL.
    This action installs CNPG operator, creates a PostgreSQL cluster for Keycloak,
    and deploys Keycloak via the Keycloak Operator.

inputs:
    namespace:
        description: Kubernetes namespace for deployment
        required: false
        default: camunda
    keycloak-mode:
        description: |
            Keycloak deployment mode:
            - 'domain': With ingress for domain access (nginx)
            - 'domain-openshift': With ingress for OpenShift router
            - 'no-domain': Without ingress (port-forward access)
        required: false
        default: no-domain
    domain-name:
        description: Domain name (required for domain mode)
        required: false
        default: ''
    cnpg-operator-namespace:
        description: Namespace for CNPG operator
        required: false
        default: cnpg-system

outputs:
    keycloak-admin-secret:
        description: Name of the Keycloak admin secret
        value: keycloak-initial-admin
    keycloak-service:
        description: Keycloak service name
        value: keycloak-service
    keycloak-port:
        description: Keycloak service port
        value: '8080'

runs:
    using: composite
    steps:
        - name: Install CloudNativePG Operator
          shell: bash
          env:
              # renovate: datasource=github-releases depName=cloudnative-pg/cloudnative-pg
              CNPG_VERSION: 1.28.0
          run: |
              set -euo pipefail

              echo "üêò Installing CloudNativePG operator v${CNPG_VERSION}..."

              kubectl apply -n "${{ inputs.cnpg-operator-namespace }}" --server-side -f \
                  "https://raw.githubusercontent.com/cloudnative-pg/cloudnative-pg/release-${CNPG_VERSION%.*}/releases/cnpg-${CNPG_VERSION}.yaml"

              kubectl rollout status deployment \
                  -n "${{ inputs.cnpg-operator-namespace }}" cnpg-controller-manager \
                  --timeout=300s

              echo "‚úì CloudNativePG operator deployed"

        - name: Create PostgreSQL secrets for Keycloak
          shell: bash
          run: |
              set -euo pipefail

              NAMESPACE="${{ inputs.namespace }}"

              echo "üîê Creating PostgreSQL secrets for Keycloak..."

              # Superuser secret
              if ! kubectl get secret pg-keycloak-superuser-secret -n "$NAMESPACE" >/dev/null 2>&1; then
                  kubectl create secret generic pg-keycloak-superuser-secret \
                      -n "$NAMESPACE" \
                      --from-literal=username=postgres \
                      --from-literal=password="$(openssl rand -base64 18)"
                  echo "‚úì Created pg-keycloak-superuser-secret"
              else
                  echo "‚úì pg-keycloak-superuser-secret already exists"
              fi

              # Bootstrap secret (keycloak user)
              if ! kubectl get secret pg-keycloak-secret -n "$NAMESPACE" >/dev/null 2>&1; then
                  kubectl create secret generic pg-keycloak-secret \
                      -n "$NAMESPACE" \
                      --from-literal=username=keycloak \
                      --from-literal=password="$(openssl rand -base64 18)"
                  echo "‚úì Created pg-keycloak-secret"
              else
                  echo "‚úì pg-keycloak-secret already exists"
              fi

        - name: Deploy PostgreSQL cluster for Keycloak
          shell: bash
          run: |
              set -euo pipefail

              NAMESPACE="${{ inputs.namespace }}"

              echo "üêò Deploying PostgreSQL cluster for Keycloak..."

              cat <<EOF | kubectl apply -n "$NAMESPACE" --server-side -f -
              apiVersion: postgresql.cnpg.io/v1
              kind: Cluster
              metadata:
                  name: pg-keycloak
              spec:
                  instances: 1
                  description: PostgreSQL cluster for Keycloak (Keycloak Operator mode)
                  # renovate: datasource=docker depName=ghcr.io/cloudnative-pg/postgresql versioning=docker
                  imageName: ghcr.io/cloudnative-pg/postgresql:17.5
                  storage:
                      size: 15Gi
                  superuserSecret:
                      name: pg-keycloak-superuser-secret
                  seccompProfile:
                      type: RuntimeDefault
                  postgresql:
                      parameters:
                          lock_timeout: 30s
                          statement_timeout: '0'
                  bootstrap:
                      initdb:
                          database: keycloak
                          owner: keycloak
                          dataChecksums: true
                          secret:
                              name: pg-keycloak-secret
              EOF

              echo "‚è≥ Waiting for PostgreSQL cluster to be ready..."
              kubectl wait --for=condition=Ready --timeout=600s cluster pg-keycloak -n "$NAMESPACE"
              echo "‚úì PostgreSQL cluster deployed"

        - name: Install Keycloak Operator
          shell: bash
          env:
              # renovate: datasource=docker depName=camunda/keycloak versioning=regex:^quay-optimized-(?<major>\d+)\.(?<minor>\d+)\.(?<patch>\d+)$
              KEYCLOAK_VERSION: 26.3.2
          run: |
              set -euo pipefail

              NAMESPACE="${{ inputs.namespace }}"

              echo "üîë Installing Keycloak operator v${KEYCLOAK_VERSION}..."

              # Install CRDs
              kubectl apply --server-side -f \
                  "https://raw.githubusercontent.com/keycloak/keycloak-k8s-resources/${KEYCLOAK_VERSION}/kubernetes/keycloaks.k8s.keycloak.org-v1.yml"
              kubectl apply --server-side -f \
                  "https://raw.githubusercontent.com/keycloak/keycloak-k8s-resources/${KEYCLOAK_VERSION}/kubernetes/keycloakrealmimports.k8s.keycloak.org-v1.yml"

              # Install operator in namespace
              kubectl apply -n "$NAMESPACE" --server-side -f \
                  "https://raw.githubusercontent.com/keycloak/keycloak-k8s-resources/${KEYCLOAK_VERSION}/kubernetes/kubernetes.yml"

              kubectl wait --for=condition=available --timeout=300s deployment/keycloak-operator -n "$NAMESPACE"
              echo "‚úì Keycloak operator deployed"

        - name: Deploy Keycloak instance
          shell: bash
          env:
              # renovate: datasource=docker depName=camunda/keycloak versioning=regex:^quay-optimized-(?<major>\d+)\.(?<minor>\d+)\.(?<patch>\d+)$
              KEYCLOAK_VERSION: 26.3.2
          run: |
              set -euo pipefail

              NAMESPACE="${{ inputs.namespace }}"
              MODE="${{ inputs.keycloak-mode }}"
              DOMAIN="${{ inputs.domain-name }}"

              echo "üîë Deploying Keycloak instance (mode: $MODE)..."

              # Base Keycloak CR
              if [[ "$MODE" == "no-domain" ]]; then
                  # No-domain mode: internal hostname, no ingress
                  cat <<EOF | kubectl apply -n "$NAMESPACE" -f -
              apiVersion: k8s.keycloak.org/v2alpha1
              kind: Keycloak
              metadata:
                  name: keycloak
              spec:
                  image: docker.io/camunda/keycloak:quay-optimized-${KEYCLOAK_VERSION}
                  instances: 1
                  db:
                      url: jdbc:aws-wrapper:postgresql://pg-keycloak-rw:5432/keycloak
                      schema: public
                      usernameSecret:
                          name: pg-keycloak-secret
                          key: username
                      passwordSecret:
                          name: pg-keycloak-secret
                          key: password
                  http:
                      httpEnabled: true
                  additionalOptions:
                      - name: http-relative-path
                        value: /auth
                  ingress:
                      enabled: false
                  hostname:
                      hostname: keycloak-service
                      strict: false
                  resources:
                      limits:
                          cpu: 500m
                          memory: 1Gi
                      requests:
                          cpu: 250m
                          memory: 512Mi
              EOF

              elif [[ "$MODE" == "domain" ]]; then
                  # Domain mode with nginx ingress
                  cat <<EOF | kubectl apply -n "$NAMESPACE" -f -
              apiVersion: k8s.keycloak.org/v2alpha1
              kind: Keycloak
              metadata:
                  name: keycloak
              spec:
                  image: docker.io/camunda/keycloak:quay-optimized-${KEYCLOAK_VERSION}
                  instances: 1
                  db:
                      url: jdbc:aws-wrapper:postgresql://pg-keycloak-rw:5432/keycloak
                      schema: public
                      usernameSecret:
                          name: pg-keycloak-secret
                          key: username
                      passwordSecret:
                          name: pg-keycloak-secret
                          key: password
                  http:
                      httpEnabled: true
                  additionalOptions:
                      - name: http-relative-path
                        value: /auth
                      - name: proxy-headers
                        value: xforwarded
                      - name: hostname-strict-https
                        value: 'true'
                  ingress:
                      enabled: false
                  hostname:
                      hostname: ${DOMAIN}
                      backchannelDynamic: false
                      strict: true
                  resources:
                      limits:
                          cpu: 500m
                          memory: 1Gi
                      requests:
                          cpu: 250m
                          memory: 512Mi
              ---
              apiVersion: networking.k8s.io/v1
              kind: Ingress
              metadata:
                  name: keycloak-ingress
                  annotations:
                      kubernetes.io/tls-acme: 'true'
                      nginx.ingress.kubernetes.io/ssl-redirect: 'true'
                      nginx.ingress.kubernetes.io/force-ssl-redirect: 'true'
              spec:
                  ingressClassName: nginx
                  tls:
                      - hosts:
                            - ${DOMAIN}
                        secretName: camunda-keycloak-tls
                  rules:
                      - host: ${DOMAIN}
                        http:
                            paths:
                                - path: /auth
                                  pathType: Prefix
                                  backend:
                                      service:
                                          name: keycloak-service
                                          port:
                                              number: 8080
              EOF

              elif [[ "$MODE" == "domain-openshift" ]]; then
                  # Domain mode with OpenShift router
                  cat <<EOF | kubectl apply -n "$NAMESPACE" -f -
              apiVersion: k8s.keycloak.org/v2alpha1
              kind: Keycloak
              metadata:
                  name: keycloak
              spec:
                  image: docker.io/camunda/keycloak:quay-optimized-${KEYCLOAK_VERSION}
                  instances: 1
                  db:
                      url: jdbc:aws-wrapper:postgresql://pg-keycloak-rw:5432/keycloak
                      schema: public
                      usernameSecret:
                          name: pg-keycloak-secret
                          key: username
                      passwordSecret:
                          name: pg-keycloak-secret
                          key: password
                  http:
                      httpEnabled: true
                  additionalOptions:
                      - name: http-relative-path
                        value: /auth
                      - name: proxy-headers
                        value: xforwarded
                      - name: hostname-strict-https
                        value: 'true'
                  ingress:
                      enabled: false
                  hostname:
                      hostname: ${DOMAIN}
                      backchannelDynamic: false
                      strict: true
                  resources:
                      limits:
                          cpu: 500m
                          memory: 1Gi
                      requests:
                          cpu: 250m
                          memory: 512Mi
              ---
              apiVersion: networking.k8s.io/v1
              kind: Ingress
              metadata:
                  name: keycloak-ingress
                  annotations:
                      route.openshift.io/termination: edge
                      haproxy.router.openshift.io/disable_cookies: 'true'
              spec:
                  ingressClassName: openshift-default
                  tls:
                      - hosts:
                  rules:
                      - host: ${DOMAIN}
                        http:
                            paths:
                                - path: /auth
                                  pathType: Prefix
                                  backend:
                                      service:
                                          name: keycloak-service
                                          port:
                                              number: 8080
              EOF
              fi

              echo "‚è≥ Waiting for Keycloak to be ready..."
              kubectl wait --for=condition=Ready --timeout=600s keycloak --all -n "$NAMESPACE"
              echo "‚úì Keycloak instance deployed"

        - name: Verify Keycloak admin secret
          shell: bash
          run: |
              set -euo pipefail

              NAMESPACE="${{ inputs.namespace }}"

              if kubectl get secret keycloak-initial-admin -n "$NAMESPACE" >/dev/null 2>&1; then
                  echo "‚úì keycloak-initial-admin secret exists"
              else
                  echo "‚ùå ERROR: keycloak-initial-admin secret not found!"
                  exit 1
              fi

        - name: Create identity secrets for components
          shell: bash
          run: |
              set -euo pipefail

              NAMESPACE="${{ inputs.namespace }}"

              echo "üîê Creating identity-secret-for-components..."

              # Generate random secrets for all components
              IDENTITY_CLIENT_SECRET="$(openssl rand -hex 16)"
              OPTIMIZE_CLIENT_SECRET="$(openssl rand -hex 16)"
              ORCHESTRATION_CLIENT_SECRET="$(openssl rand -hex 16)"
              CONNECTORS_CLIENT_SECRET="$(openssl rand -hex 16)"
              CONSOLE_CLIENT_SECRET="$(openssl rand -hex 16)"
              WEBMODELER_CLIENT_SECRET="$(openssl rand -hex 16)"
              FIRST_USER_PASSWORD="$(openssl rand -hex 16)"

              kubectl create secret generic identity-secret-for-components \
                  --namespace "$NAMESPACE" \
                  --from-literal=identity-client-secret="$IDENTITY_CLIENT_SECRET" \
                  --from-literal=optimize-client-secret="$OPTIMIZE_CLIENT_SECRET" \
                  --from-literal=orchestration-client-secret="$ORCHESTRATION_CLIENT_SECRET" \
                  --from-literal=connectors-client-secret="$CONNECTORS_CLIENT_SECRET" \
                  --from-literal=console-client-secret="$CONSOLE_CLIENT_SECRET" \
                  --from-literal=webmodeler-client-secret="$WEBMODELER_CLIENT_SECRET" \
                  --from-literal=identity-first-user-password="$FIRST_USER_PASSWORD" \
                  --dry-run=client -o yaml | kubectl apply -f -

              echo "‚úì identity-secret-for-components created"
