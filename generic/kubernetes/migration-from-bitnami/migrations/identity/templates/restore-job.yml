---
# PostgreSQL Restore Job using pg_restore
# Required env vars:
#   NAMESPACE, JOB_NAME, PG_IMAGE
#   TARGET_PG_HOST, TARGET_PG_PORT, TARGET_PG_DATABASE, TARGET_PG_USERNAME
#   DB_SECRET_NAME
#   BACKUP_PVC, BACKUP_FILE
# Usage: envsubst < restore-job.yml | kubectl apply -f -
apiVersion: batch/v1
kind: Job
metadata:
    name: ${JOB_NAME}
    namespace: ${NAMESPACE}
    labels:
        app: identity-migration
        migration.camunda.io/type: restore
        migration.camunda.io/component: postgresql
spec:
    ttlSecondsAfterFinished: 3600
    backoffLimit: 2
    template:
        metadata:
            labels:
                app: identity-migration
                migration.camunda.io/type: restore
        spec:
            restartPolicy: Never
            containers:
                - name: restore
                  image: ${PG_IMAGE}
                  command:
                      - /bin/bash
                      - -c
                      - |
                        set -e

                        echo "============================================="
                        echo "PostgreSQL Restore - Identity"
                        echo "============================================="
                        echo "Target: ${TARGET_PG_HOST}:${TARGET_PG_PORT}"
                        echo "Database: ${TARGET_PG_DATABASE}"
                        echo ""

                        echo "Waiting for target PostgreSQL to be ready..."
                        until pg_isready -h "${TARGET_PG_HOST}" -p "${TARGET_PG_PORT}" -U "${TARGET_PG_USERNAME}"; do
                          echo "Waiting for PostgreSQL..."
                          sleep 5
                        done

                        echo "Target PostgreSQL is ready"

                        # Determine backup file
                        if [ -f "/backup/identity/${BACKUP_FILE}" ]; then
                          RESTORE_FILE="/backup/identity/${BACKUP_FILE}"
                        else
                          echo "Specified backup not found, using latest..."
                          RESTORE_FILE=$(ls -t /backup/identity/identity-db-*.dump 2>/dev/null | head -1)
                        fi

                        if [ -z "${RESTORE_FILE}" ]; then
                          echo "ERROR: No backup file found!"
                          exit 1
                        fi

                        echo "Restoring from: ${RESTORE_FILE}"

                        # Restore using pg_restore
                        # --clean: drop existing objects before restore
                        # --if-exists: don't error if objects don't exist
                        # --no-owner: don't set ownership to match source
                        # --no-privileges: don't restore privileges
                        pg_restore -h "${TARGET_PG_HOST}" -p "${TARGET_PG_PORT}" -U "${TARGET_PG_USERNAME}" \
                          -d "${TARGET_PG_DATABASE}" \
                          --clean --if-exists \
                          --no-owner --no-privileges \
                          "${RESTORE_FILE}" || {
                            echo "pg_restore completed with warnings (this is often normal)"
                          }

                        echo ""
                        echo "Validating restore..."

                        # Count tables
                        TABLE_COUNT=$(psql -h "${TARGET_PG_HOST}" -p "${TARGET_PG_PORT}" \
                          -U "${TARGET_PG_USERNAME}" -d "${TARGET_PG_DATABASE}" \
                          -t -c "SELECT count(*) FROM information_schema.tables WHERE table_schema = 'public'")

                        echo "Tables in restored database: ${TABLE_COUNT}"

                        echo ""
                        echo "Restore complete!"

                  env:
                      - name: PGPASSWORD
                        valueFrom:
                            secretKeyRef:
                                name: ${DB_SECRET_NAME}
                                key: password
                  volumeMounts:
                      - name: backup
                        mountPath: /backup
            volumes:
                - name: backup
                  persistentVolumeClaim:
                      claimName: ${BACKUP_PVC}
